% mlrVol.m
%
%        $Id:$ 
%      usage: mlrVol(filename,<filename2>,'imageOrientation=0')
%         by: justin gardner
%       date: 08/15/11
%    purpose: Volume viewer to display volume multi-dimensional data (usually 3D volumes or 4D epi sequences)
%
%             You can load using filenames, view/scanNum/groupNum,
%             select from a dialog box in the current or canonical
%             directory, or from a struct -> see mlrImageParseArgs
%             for details.
%
%             If qform information exists (from a nifti header) it will orient the axis in LPI and label axis
%             correctly (left/right, posterior/anterior, inferior/superior). If you want to view the
%             image in its native orientation (i.e. order it is written into the matrix, then set the
%             input argument:
%
%             'imageOrienation=1'
%
%             With two filename arguments, will show the alignment between the two images, using
%             the sforms if they are both set / or the qforms otherwise. If neither one is set
%             will display with an identity alignment. A dialog box allows you to fiddle manually
%             with the alignment
%
%             Other options:
%
%             'verbose=1' Set verbose level, 0 for quiet. 1 for normal. 2 for detailed info.
function retval = mlrVol(varargin)

% check arguments
if nargin < 1
  help mlrVol
  return
end

global gVol;

if ~(isscalar(varargin{1}) && isnumeric(varargin{1}))
  % init the system
  [sysNum imageArgs] = initSystem(varargin);
  if isempty(sysNum),return,end

  % load the volumes
  for i = 1:length(imageArgs)
    loadVolume(imageArgs{i},sysNum);
  end

  % display the volume
  refreshDisplay(sysNum);
  
  % display controls
  if gVol{sysNum}.displayControls,displayControls(sysNum);end
else
  % handle events generated by the GUI
  switch (varargin{1})
   case 1
    mouseDownHandler(varargin{2});
   case 2
    mouseMoveHandler(varargin{2});
   case 3
    textHandler(varargin{2},varargin{3});
   case 4
    incdecHandler(varargin{2},varargin{3},varargin{4});
   case 5
    buttonHandler(varargin{2},varargin{3});
   case 6
    closeHandler(varargin{2});
  end
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    Handlers
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%
%    mouseDownHandler    %
%%%%%%%%%%%%%%%%%%%%%%%%%%
function mouseDownHandler(sysNum)

set(gcf,'Pointer','arrow');
global gVol;
vol = gVol{sysNum}.vols(1);

% stop any ongoing animation
gVol{sysNum}.animating = 0;

% get the mouse pos
coord = getMouseCoord(sysNum);
if isempty(coord),return,end

% and set the volume coordinate
setVolCoord(sysNum,1,coord);

% refresh the display
refreshDisplay(sysNum);

%%%%%%%%%%%%%%%%%%%%%%%%%%
%    mouseMoveHandler    %
%%%%%%%%%%%%%%%%%%%%%%%%%%
function mouseMoveHandler(sysNum)

global gVol;
vol = gVol{sysNum}.vols(1);

coord = getMouseCoord(sysNum);
if isempty(coord)
  set(gcf,'Pointer','arrow');
  set(gVol{sysNum}.hCoordTextbox(1),'String',vol.coord(1));
  set(gVol{sysNum}.hCoordTextbox(2),'String',vol.coord(2));
  set(gVol{sysNum}.hCoordTextbox(3),'String',vol.coord(3));
  updateExtraCoords(sysNum);
  % nDims hard coded to 5 here
  set(gVol{sysNum}.hValTextbox(1),'String',vol.data(vol.coord(1),vol.coord(2),vol.coord(3),vol.coord(4),vol.coord(5)));
else
  set(gcf,'Pointer','fullcrosshair');
  set(gVol{sysNum}.hCoordTextbox(1),'String',coord(1));
  set(gVol{sysNum}.hCoordTextbox(2),'String',coord(2));
  set(gVol{sysNum}.hCoordTextbox(3),'String',coord(3));
  updateExtraCoords(sysNum);
  % nDims hard coded to 5 here
  set(gVol{sysNum}.hValTextbox(1),'String',vol.data(coord(1),coord(2),coord(3),coord(4),coord(5)));
end

%%%%%%%%%%%%%%%%%%%%%
%%   textHandler   %%
%%%%%%%%%%%%%%%%%%%%%
function textHandler(sysNum,textboxNum)

global gVol;
vol = gVol{sysNum}.vols(1);

% turn off animation
gVol{sysNum}.animating = 0;

% textboxNums that are negative are the extra coordinates
if textboxNum < 0
  % set coordinate according to extra
  setCoordToExtra(sysNum);
end

% get number of dimensions
nDim = gVol{sysNum}.vols(1).h.nDim;

% get coordinate
for iCoord = 1:nDim
  coord(iCoord) = str2num(get(gVol{sysNum}.hCoordTextbox(iCoord),'String'));
end
coord = round(coord);

if any(coord<1) || any(coord(:)>vol.h.dim(1:nDim)')
  for iCoord = 1:nDim
    set(gVol{sysNum}.hCoordTextbox(1),'String',vol.coord(iCoord));
  end
  return
end

% nDims hard coded to 5 here
coord(end+1:5) = 1;

% set the volume coord
setVolCoord(sysNum,1,coord);

% nDims hard coded to 5 here
vol = gVol{sysNum}.vols(1);
set(gVol{sysNum}.hValTextbox(1),'String',vol.data(vol.coord(1),vol.coord(2),vol.coord(3),vol.coord(4),vol.coord(5)));

% and redisplay
refreshDisplay(sysNum);

%%%%%%%%%%%%%%%%%%%%%%%
%%   incdecHandler   %%
%%%%%%%%%%%%%%%%%%%%%%%
function incdecHandler(textNum,incdec,sysNum)

global gVol;
vol = gVol{sysNum}.vols(1);

% turn off animation
gVol{sysNum}.animating = false;

% get the textbox we are updating. If textNum is less
% than zero we are updating the extra coord textboxes
if textNum > 0
  hTextbox = gVol{sysNum}.hCoordTextbox(textNum);
else
  hTextbox = gVol{sysNum}.hExtraCoordTextbox(-textNum);
end
  
% inc or dec the text box
val = str2num(get(hTextbox,'String'));
val = val+incdec;

% if we are doing an extra coordinate than transform
if (textNum < 0)
  set(hTextbox,'String',val);
  textHandler(sysNum,-1);
elseif (val>=1) && (val<=vol.h.dim(textNum))
  % if we have made a valid change then set it
  set(hTextbox,'String',val);
  % now refresh
  textHandler(sysNum,1);
end

%%%%%%%%%%%%%%%%%%%%%%%
%%   buttonHandler   %%
%%%%%%%%%%%%%%%%%%%%%%%
function buttonHandler(textNum,sysNum)

global gVol;
vol = gVol{sysNum}.vols(1);

% display controls
if textNum < 0
  switch textNum
   case -1
    closeHandler(sysNum);
   case -2
    displayControls(sysNum);
  end
  return
end

% if we are already running the animation, then turn it off
if gVol{sysNum}.animating == textNum
  gVol{sysNum}.animating = 0;
  return
end

% get number of dimensions
nDim = vol.h.nDim;

% start the animation
gVol{sysNum}.animating = textNum;
coord = vol.coord;

% loop that runs the animation
while ~isempty(gVol{sysNum}) && gVol{sysNum}.animating
  % increment coord, go forward for an axis that moves in
  % the positive direction 
  if (textNum > 3) || (vol.axisDir(textNum) == 1)
    coord(textNum) = coord(textNum)+1;
    if coord(textNum) > vol.h.dim(textNum)
      coord(textNum) = 1;
    end
    % and negatively otherwise
  else
    coord(textNum) = coord(textNum)-1;
    if coord(textNum) < 1
      coord(textNum) = vol.h.dim(textNum);
    end
  end
  % set the volume coord
  setVolCoord(sysNum,1,coord);
  % set the text boxes
  for iCoord = 1:nDim
    set(gVol{sysNum}.hCoordTextbox(iCoord),'String',coord(iCoord));
  end
  set(gVol{sysNum}.hValTextbox(1),'String',vol.data(coord(1),coord(2),coord(3),coord(4),coord(5)));
  % and refresh
  refreshDisplay(sysNum);
end
%%%%%%%%%%%%%%%%%%%%%%
%%   closeHandler   %%
%%%%%%%%%%%%%%%%%%%%%%
function closeHandler(sysNum)

global gVol;

% stop any ongoing animation
if gVol{sysNum}.animating
  gVol{sysNum}.animating = 0;
end

% close correlation figure if it exists
if isfield(gVol{sysNum},'dispCorrelationFig') && ishandle(gVol{sysNum}.dispCorrelationFig)
  close(gVol{sysNum}.dispCorrelationFig);
end

uniqueFigs = unique(gVol{sysNum}.fig);
% close the figures
for i = 1:length(uniqueFigs)
  % get the location of the figure - note that if
  % we ever have multiple figures than we will need to change
  % this code here and in initSystem to have more figlocs saved
  mrSetFigLoc('mlrVol',get(uniqueFigs(i),'Position'));

  % close the figure
  delete(uniqueFigs(i));
end

mrParamsClose;

% remove the variable
gVol{sysNum} = [];

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    Coordinate display helper functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   updateExtraCoords   %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%
function updateExtraCoords(sysNum)

global gVol
if gVol{sysNum}.vols(1).altXforms.n > 0
  % get the current coord
  coord(1) = str2num(get(gVol{sysNum}.hCoordTextbox(1),'String'));
  coord(2) = str2num(get(gVol{sysNum}.hCoordTextbox(2),'String'));
  coord(3) = str2num(get(gVol{sysNum}.hCoordTextbox(3),'String'));
  coord(4) = 1;
  coord = coord(:);
  
  % get the extra coordinate xform
  xform = gVol{sysNum}.vols(1).altXforms.xforms{gVol{sysNum}.vols(1).altXforms.currentXform};

  % convert
  coord = xform * coord;
  
  % and display
  set(gVol{sysNum}.hExtraCoordTextbox(1),'String',sprintf('%0.1f',coord(1)));
  set(gVol{sysNum}.hExtraCoordTextbox(2),'String',sprintf('%0.1f',coord(2)));
  set(gVol{sysNum}.hExtraCoordTextbox(3),'String',sprintf('%0.1f',coord(3)));
end

%%%%%%%%%%%%%%%%%%%%%%%%%
%%   setCoordToExtra   %%
%%%%%%%%%%%%%%%%%%%%%%%%%
function setCoordToExtra(sysNum)

global gVol;
vol = gVol{sysNum}.vols(1);

% get coordinates form extra textbox
coord(1) = str2num(get(gVol{sysNum}.hExtraCoordTextbox(1),'String'));
coord(2) = str2num(get(gVol{sysNum}.hExtraCoordTextbox(2),'String'));
coord(3) = str2num(get(gVol{sysNum}.hExtraCoordTextbox(3),'String'));
coord(4) = 1;
coord = coord(:);

% get the extra coordinate xform
xform = gVol{sysNum}.vols(1).altXforms.xforms{gVol{sysNum}.vols(1).altXforms.currentXform};

% convert
coord = round(inv(xform) * coord);

% check to see if we have valid coordinates
if all(coord(1:3) > 0) && all(coord(1:3)' <= vol.h.dim(1:3))
  % if so, then display
  set(gVol{sysNum}.hCoordTextbox(1),'String',sprintf('%0.0f',coord(1)));
  set(gVol{sysNum}.hCoordTextbox(2),'String',sprintf('%0.0f',coord(2)));
  set(gVol{sysNum}.hCoordTextbox(3),'String',sprintf('%0.0f',coord(3)));
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   makeExtraCoordControls   %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function makeExtraCoordControls(sysNum,shortName,col)

global gVol;

if ~isfield(gVol{sysNum},'hExtraCoordTitle')
  gVol{sysNum}.hExtraCoordTitle(1) = makeTextbox(sysNum,sprintf('%s X',shortName),2,col);
  gVol{sysNum}.hExtraCoordTextbox(1) = makeTextboxIncDec(sysNum,'',-1,1,col);
  gVol{sysNum}.hExtraCoordTitle(2) = makeTextbox(sysNum,sprintf('%s Y',shortName),2,col+1);
  gVol{sysNum}.hExtraCoordTextbox(2) = makeTextboxIncDec(sysNum,'',-2,1,col+1);
  gVol{sysNum}.hExtraCoordTitle(3) = makeTextbox(sysNum,sprintf('%s Z',shortName),2,col+2);
  gVol{sysNum}.hExtraCoordTextbox(3) = makeTextboxIncDec(sysNum,'',-3,1,col+2);
end

%%%%%%%%%%%%%%%%%%%%%%%
%    getMouseCoord    %
%%%%%%%%%%%%%%%%%%%%%%%
function coord = getMouseCoord(sysNum)

coord = [];viewNum = [];

global gVol;
vol = gVol{sysNum}.vols(1);

% figure out which axis we are on
pointerLoc = get(gcf,'CurrentPoint');
pos = get(gcf,'Position');
pos = pointerLoc./pos(3:4);
subplotNum = ceil(pos(1)*3);
if (subplotNum>0) && (subplotNum<=3)
  a = subplot(gVol{sysNum}.subplotRows(1),gVol{sysNum}.subplotCols(1),subplotNum);
else
  return
end
viewNum = find(gVol{sysNum}.a(1,1:3) == a);
if isempty(viewNum),return,end

% get pointer loc
pointerLoc = get(a,'CurrentPoint');
pointerLoc = round(pointerLoc(1,2:-1:1));

% check transpose to see which coordinate is which
% note that matlab displays matrices in a transposed fashion
if ~vol.transpose(viewNum)
  pointerX = pointerLoc(1);
  pointerY = pointerLoc(2);
else
  pointerX = pointerLoc(2);
  pointerY = pointerLoc(1);
end

% check image boundaries 
if (pointerX < 1) | (pointerX > vol.h.dim(vol.xDim(viewNum))),return,end
if (pointerY < 1) | (pointerY > vol.h.dim(vol.yDim(viewNum))),return,end


% get the coordinate. Note that we have to be careful both of whether the axis
% is flipped AND whether there was a transpose (since the y-axis goes in
% the opposite direction as x for matlab displayed images
if ((vol.axisDir(vol.xDim(viewNum)) == 1) && (vol.transpose(viewNum))) || ((vol.axisDir(vol.xDim(viewNum)) == -1) && (~vol.transpose(viewNum)))
  coord(vol.xDim(viewNum)) = pointerX;
else
  coord(vol.xDim(viewNum)) = vol.h.dim(vol.xDim(viewNum)) - pointerX + 1;
end
% note that for the y-dimension, matlab's axis are flipped
if ((vol.axisDir(vol.yDim(viewNum)) == -1) && (vol.transpose(viewNum))) || ((vol.axisDir(vol.yDim(viewNum)) == 1) && (~vol.transpose(viewNum)))
  coord(vol.yDim(viewNum)) = pointerY;
else
  coord(vol.yDim(viewNum)) = vol.h.dim(vol.yDim(viewNum)) - pointerY + 1;
end
coord(vol.viewDim(viewNum)) = vol.coord(vol.viewDim(viewNum));

% nDims hard coded to 5 here
coord(end+1:5) = 1;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    main display functions (refreshDisplay and dispVolume)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%    refreshDisplay    %
%%%%%%%%%%%%%%%%%%%%%%%%
function refreshDisplay(sysNum)

global gVol;

% get current figure
f = gcf;

% set the figure to the mlrVol figure
figure(gVol{sysNum}.vols(1).fig(1));

% go through each volume
for iVol = 1:gVol{sysNum}.n
  % if the volume is tethered then set its coordinates according
  % to whatever volume it is tethered to.
  if gVol{sysNum}.vols(iVol).tethered
    setTetheredCoord(sysNum,iVol,gVol{sysNum}.vols(iVol).tethered);
  end

  % display the volume
  dispVolume(iVol,sysNum)

  % set that we have displayed this coordinate
  gVol{sysNum}.vols(iVol).curCoord = gVol{sysNum}.vols(iVol).coord;
end

% update the display of other coordinates
updateExtraCoords(sysNum);

% draw
drawnow;

% and reset figure back to what was current before this call
figure(f);


%%%%%%%%%%%%%%%%%%%%
%    dispVolume    %
%%%%%%%%%%%%%%%%%%%%
function dispVolume(iVol,sysNum)

global gVol;
vol = gVol{sysNum}.vols(iVol);

% view labels
viewLabel = {'Sagittal','Coronal','Axial'};

for iView = 1:3
  % see if we need to redisplay, first condition is whether we have changed the volume or other dimenson
  % the second condition is for primary volumes whether we have updated the coordinates being displayed
  % in the view, and the third condition is for tethered volumes - whether we have change the coordinates
  % for the volume we are tethered to
  if (~isequal(vol.curCoord(4:end),vol.coord(4:end)) || ...
      (~vol.tethered && ~isequal(vol.curCoord(vol.viewDim(iView)), ...
				 vol.coord(vol.viewDim(iView)))) || ...
      vol.tethered)
    % get the slice
    % nDims hard coded to 5 here
    if vol.tethered
      % tethered volumes have their display slices precomputed (by interpolation) in 
      % setTetheredCoord
      dispSlice = vol.dispSlice{iView};

      % get the axis that we are tethered to (so that we can draw the overlay)
      aTether = subplot(gVol{sysNum}.subplotRows(iView),gVol{sysNum}.subplotCols(iView),gVol{sysNum}.vols(vol.tethered).subplotNum(iView));

      % the transpose and axis directions need to be taken from the volume this is tethered to
      % prepare image for display
      [dispOverlaySlice xLabelStr yLabelStr] = prepareImageForDisplay(dispSlice,gVol{sysNum}.vols(vol.tethered),iView);
      
      % if we are not displaying the interpolated image in the
      % second row, then we have to prepare the image that
      % corresponds to the same location
      if gVol{sysNum}.displayInterpolated
	dispSlice = dispOverlaySlice;
      else
	% need to get the coordinate of the tethered to volume
	% in these coordinates
	dispSlice = getMatchingSlice(sysNum,vol,iView);
	[dispSlice xLabelStr yLabelStr] = prepareImageForDisplay(dispSlice,vol,iView);
      end
    else
      % otherwise, grab the data for this image
      dispSlice = squeeze(vol.data(vol.viewIndexes{iView,1},vol.viewIndexes{iView,2},vol.viewIndexes{iView,3},vol.coord(4),vol.coord(5)));

      % prepare image for display
      [dispSlice xLabelStr yLabelStr] = prepareImageForDisplay(dispSlice,vol,iView);
    end

    % get the correct axis to draw into
    a = subplot(gVol{sysNum}.subplotRows(iView),gVol{sysNum}.subplotCols(iView),vol.subplotNum(iView));

    % clear the axis
    cla(a);

    % and display the image
    if isempty(dispSlice)
      axis off;
    else
      subimage(dispSlice,gray(256));
      % turn off labels
      set(a,'XTickLabel','');
      set(a,'YTickLabel','');
      % and put on what axis we have
      xlabel(a,xLabelStr);
      ylabel(a,yLabelStr);
    end

    % set title
    titleStr = sprintf('%s: %s (%ix%i)',vol.name,viewLabel{iView},size(dispSlice,2),size(dispSlice,1));
    h = title(titleStr,'Interpreter','none');
    
    % and display the overlay
    if vol.tethered
      % switch to the axis that this volume is tethered to (i.e. draw over the other image)
      axes(aTether);
      hold on;
      % display
      gVol{sysNum}.vols(iVol).overlay(iView) = subimage(dispOverlaySlice,hot(256));
      % set alpha
      gVol{sysNum}.vols(iVol).overlayMask{iView} = ~isnan(dispOverlaySlice(:));
      alphaData = zeros(size(dispOverlaySlice));
      if gVol{sysNum}.overlayToggleState
	alphaData(gVol{sysNum}.vols(iVol).overlayMask{iView}) = gVol{sysNum}.overlayAlpha;
      end
      set(gVol{sysNum}.vols(iVol).overlay(iView),'AlphaData',alphaData);
      hold off;
    end
    
  end
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    Helper display functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   getMatchingSlice   %%
%%%%%%%%%%%%%%%%%%%%%%%%%%
function dispSlice = getMatchingSlice(sysNum,vol,iView)

global gVol;

% get coordinated of volume we are tethered to
coord = gVol{sysNum}.vols(vol.tethered).coord;
coord(4) = 1;coord = coord(1:4);coord = coord(:);

% convert to this volume coordinates
coord = round(applySystemXform(sysNum,vol.xform)*coord);
coord = coord(1:3);

% FIX: this hardcodes the volume number to 1
coord(end+1:5) = 1;

% check to see if coordinates are in volume
if any(coord(1:3)<1) || any(coord(1:3)'>vol.h.dim(1:3))
  dispSlice = [];
  return
end

% if not set the volume coordinates
setVolCoord(sysNum,vol.volnum,coord);
vol = gVol{sysNum}.vols(vol.volnum);

% and get display slice
dispSlice = squeeze(vol.data(vol.viewIndexes{iView,1},vol.viewIndexes{iView,2},vol.viewIndexes{iView,3},vol.coord(4),vol.coord(5)));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   prepareImageForDisplay   %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [dispSlice xLabelStr yLabelStr] = prepareImageForDisplay(dispSlice,vol,iView)

if isempty(dispSlice)
  xLabelStr = '';yLabelStr = '';
  return
end
% clip
%  dispSlice = clipImage(dispSlice);

% make into image with index values
minDispSlice = min(dispSlice(:));
maxDispSlice = max(dispSlice(:));
dispSlice = ceil(256*(dispSlice-minDispSlice)/(maxDispSlice-minDispSlice));

% do transpose if necessary
if vol.transpose(iView)
  dispSlice = dispSlice';
  xLabelStr = vol.dispAxisLabels{vol.xDim(iView)};
  yLabelStr = vol.dispAxisLabels{vol.yDim(iView)};
  % flip axis if necessary (note that Matlab shows the x axis as - to +
  % and the y -axis in the opposite orientation, so we treat the x and y differently)
  if vol.axisDir(vol.xDim(iView)) == -1,dispSlice = fliplr(dispSlice);end
  if vol.axisDir(vol.yDim(iView)) == 1,dispSlice = flipud(dispSlice);end
else
  xLabelStr = vol.dispAxisLabels{vol.yDim(iView)};
  yLabelStr = vol.dispAxisLabels{vol.xDim(iView)};
  % flip axis if necessary (note that Matlab shows the x axis as - to +
  % and the y -axis in the opposite orientation, so we treat the x and y differently)
  if vol.axisDir(vol.xDim(iView)) == 1,dispSlice = flipud(dispSlice);end
  if vol.axisDir(vol.yDim(iView)) == -1,dispSlice = fliplr(dispSlice);end
end



%%%%%%%%%%%%%%%%%%%
%    clipImage    %
%%%%%%%%%%%%%%%%%%%
function img = clipImage(img)

% Choose a sensible clipping value
histThresh = length(img(:))/1000;
[cnt, val] = hist(img(:),100);
goodVals = find(cnt>histThresh);
if isempty(goodVals)
  clipMin = 0;clipMax = 0;
else
  clipMin = val(min(goodVals));
  clipMax = val(max(goodVals));
end

% and convert the image
img(img<clipMin) = clipMin;
img(img>clipMax) = clipMax;
if (clipMax-clipMin) > 0
  img = 255*(img-clipMin)./(img-clipMin);
end

%%%%%%%%%%%%%%%%%%%%%
%    setVolCoord    %
%%%%%%%%%%%%%%%%%%%%%
function setVolCoord(sysNum,iVol,coord)

global gVol;

% check bounds
coord(coord<1) = 1;
dim = gVol{sysNum}.vols(iVol).h.dim;
outOfBounds = coord(1:length(dim)) > dim;
coord(outOfBounds) = dim(outOfBounds);

% set the current x,y,z coordinate
gVol{sysNum}.vols(iVol).coord = coord;

% now this sets the indexes from the volume for which the
% image will be displayed
for iView = 1:3
  for jAxis = 1:3
    if jAxis ~= gVol{sysNum}.vols(iVol).viewDim(iView)
      gVol{sysNum}.vols(iVol).viewIndexes{iView,jAxis} = 1:gVol{sysNum}.vols(iVol).h.dim(jAxis);
    else
      gVol{sysNum}.vols(iVol).viewIndexes{iView,jAxis} = gVol{sysNum}.vols(iVol).coord(jAxis);
    end
  end
end

%%%%%%%%%%%%%%%%%%%%%%%%%%
%    setTetheredCoord    %
%%%%%%%%%%%%%%%%%%%%%%%%%%
function setTetheredCoord(sysNum,iVol,iRefvol)

global gVol;

% get coord we are tethering to
coord = gVol{sysNum}.vols(iRefvol).coord;

% see if we have already updated
if isequal(gVol{sysNum}.vols(iVol).curCoord,coord)
  return
end

% look in cache for precalculate
dispSlice = mrCache('find',gVol{sysNum}.vols(iVol).c,mrnum2str(coord));
if ~isempty(dispSlice)
  gVol{sysNum}.vols(iVol).dispSlice = dispSlice;
else
  % create an image
  for iView = 1:3
    % get the coordinates of the reference volume
    [x y z] = ndgrid(gVol{sysNum}.vols(iRefvol).viewIndexes{iView,1},gVol{sysNum}.vols(iRefvol).viewIndexes{iView,2},gVol{sysNum}.vols(iRefvol).viewIndexes{iView,3});
    s = size(x);
    % make into coords for multiplying
    coords = [x(:) y(:) z(:)]';
    coords(4,:) = 1;
    % convert from the reference volume coordinates to our coordinates
    coords = applySystemXform(sysNum,gVol{sysNum}.vols(iVol).xform) * coords;
    x = reshape(coords(1,:),s);
    y = reshape(coords(2,:),s);
    z = reshape(coords(3,:),s);
    % get the interpolated image (note that interp3 needs to have y
    % and x swaped to work correctly here)
    coord = gVol{sysNum}.vols(iVol).coord;
    % nDims hard coded to 5 here
    gVol{sysNum}.vols(iVol).dispSlice{iView} = squeeze(interp3(gVol{sysNum}.vols(iVol).data(:,:,:,coord(4),coord(5)),y,x,z,gVol{sysNum}.interpMethod,nan));
  end
  % save in cache
  gVol{sysNum}.vols(iVol).c = mrCache('add',gVol{sysNum}.vols(iVol).c,mrnum2str(coord),gVol{sysNum}.vols(iVol).dispSlice);
end

% set the coordinate so that we update correctly
gVol{sysNum}.vols(iVol).coord = coord;

%%%%%%%%%%%%%%%%%%%%%%%%
%%   dispHeaderInfo   %%
%%%%%%%%%%%%%%%%%%%%%%%%
function dispHeaderInfo(sysNum,vol)

global gVol;

if gVol{sysNum}.verbose
  mlrImageHeaderDisp(vol.h,'verbose',gVol{sysNum}.verbose);
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    UI control functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%
%%   makeTextbox   %%
%%%%%%%%%%%%%%%%%%%%%
function h = makeTextbox(sysNum,displayString,rownum,colnum);

h = uicontrol('Style','text','String',displayString,'Position',getUIControlPos(sysNum,rownum,colnum,1),'FontSize',10,'FontName','Helvetica','HorizontalAlignment','Center','Callback',sprintf('mlrVol(3,%i)',sysNum));

%%%%%%%%%%%%%%%%%%%%%%%
%%   makePushbuton   %%
%%%%%%%%%%%%%%%%%%%%%%%
function h = makeButton(sysNum,displayString,textboxNum,rownum,colnum)

h = uicontrol('Style','pushbutton','String',displayString,'Position',getUIControlPos(sysNum,rownum,colnum,1),'FontSize',10,'FontName','Helvetica','HorizontalAlignment','Center','Callback',sprintf('mlrVol(5,%i,%i)',textboxNum,sysNum));

%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   makeTextboxIncDec   %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [h hIncDec] = makeTextboxIncDec(sysNum,displayString,textboxNum,rownum,colnum)

% make textbox
h = uicontrol('Style','edit','String',displayString,'Position',getUIControlPos(sysNum,rownum,colnum+.125,0.75),'FontSize',10,'FontName','Helvetica','HorizontalAlignment','Center','Callback',sprintf('mlrVol(3,%i,%i)',sysNum,textboxNum));

% put up incdec buttons
hIncDec(1) = uicontrol('Style','pushbutton','String','<','Position',getUIControlPos(sysNum,rownum,colnum,.1),'FontSize',10,'FontName','Helvetica','HorizontalAlignment','Center','Callback',sprintf('mlrVol(4,%i,-1,%i)',textboxNum,sysNum));
hIncDec(2) = uicontrol('Style','pushbutton','String','>','Position',getUIControlPos(sysNum,rownum,colnum+.9,.1),'FontSize',10,'FontName','Helvetica','HorizontalAlignment','Center','Callback',sprintf('mlrVol(4,%i,1,%i)',textboxNum,sysNum));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% getUIControlPos returns a location for a uicontrol
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function pos = getUIControlPos(sysNum,rownum,colnum,uisize)

global gVol;

% set this buttons width
thisButtonWidth = gVol{sysNum}.buttonWidth*uisize;

% set the position for the button
pos(1) = (gVol{sysNum}.buttonWidth+gVol{sysNum}.buttonWidthMargin)*(floor(colnum)-1)+gVol{sysNum}.buttonLeftMargin+(colnum-floor(colnum))*gVol{sysNum}.buttonWidth;
pos(2) = gVol{sysNum}.buttonBottomMargin + (gVol{sysNum}.buttonHeight+gVol{sysNum}.buttonHeightMargin)*(rownum-1);
pos(3) = thisButtonWidth;
pos(4) = gVol{sysNum}.buttonHeight;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    transformation (displaying alignment) functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%
%    applySystemXform    %
%%%%%%%%%%%%%%%%%%%%%%%%%%
function xform = applySystemXform(sysNum,xform)

global gVol;

xform = inv(shiftOriginXform) * xform * gVol{sysNum}.xform * shiftOriginXform;

%%%%%%%%%%%%%%%%%%%%
%    getVol2vol    %
%%%%%%%%%%%%%%%%%%%%
function vol2vol = getVol2vol(sysNum,vol1,vol2)

global gVol;
verbose = gVol{sysNum}.verbose;

if ~isempty(vol1.h.sform) && ~isempty(vol2.h.sform)
  vol2vol = inv(vol1.h.sform) * vol2.h.sform;
  if verbose
    dispHeader('Aliging using sform');
    disp(sprintf('%s',mrnum2str(vol2vol,'compact=0')))
    dispHeader;
  end
elseif ~isempty(vol1.h.qform) && ~isempty(vol2.h.qform)
  vol2vol = inv(vol1.h.qform) * vol2.h.qform;
  if verbose
    dispHeader('Aliging using qform');
    disp(sprintf('%s',mrnum2str(vol2vol,'compact=0')))
    dispHeader;
  end
else
  vol2vol = eye(4);
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    Auxillary functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%
%    dispHeader    %
%%%%%%%%%%%%%%%%%%%%
function retval = dispHeader(header,len,c)

% check arguments
if ~any(nargin == [0 1 2 3])
  help dispHeader
  return
end

% default header is just a full line
if nargin < 1, header = '';end

% default length
if (nargin < 2) || isempty(len),len = 60;end

% default separator character
if (nargin < 3) || isempty(c),c = '=';end

% get length of texgt
headerLen = length(header);

% if it is longer than the desired header length, then
% display two lines of separators one above and below the header
if (headerLen+2) >= len
  disp(repmat(c,1,len));
  disp(header)
  disp(repmat(c,1,len));
elseif headerLen == 0
  % if the header is empty, just display a full line
  disp(repmat(c,1,len));
else
  % otherwise put header inside separator characters
  fillerLen = ((len-(headerLen+2))/2);
  
  % display the first part
  disp(sprintf('%s %s %s',repmat(c,1,floor(fillerLen)),header,repmat(c,1,ceil(fillerLen))));
end

%%%%%%%%%%%%%%%%%%%
%    mrnum2str    %
%%%%%%%%%%%%%%%%%%%
function str = mrnum2str(num,arg1,arg2)

% just a wrapper function so that we can use mynum2str (which is in my matlab directory not in mrTools)
if exist('mynum2str')==2
  switch (nargin)
   case 1
    str = mynum2str(num);
   case 2
    str = mynum2str(num,arg1);
   case 3
    str = mynum2str(num,arg1,arg2);
  end
else
  % otherwise use matlabs normal function
  str = num2str(num(:));
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    Functions for controls
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%
%    displayControls    %
%%%%%%%%%%%%%%%%%%%%%%%%%
function displayControls(sysNum)

global gVol;

if gVol{sysNum}.n > 1
  paramsInfo = {...
    {'toggleOverlay',0,'type=pushbutton','callback',@toggleOverlay,'buttonString','Toggle overlay','callbackArg',sysNum,'Toggle display the overlay'}...
    {'overlayAlpha',gVol{sysNum}.overlayAlpha,'incdec=[-0.2 0.2]','minmax=[0 1]','callback',@overlayAlpha,'callbackArg',sysNum,'passParams=1','Change the alpha of the overlay to make it more or less transparent'}...
    {'displayInterpolated',1,'type=checkbox','callback',@displayInterpolated,'callbackArg',sysNum,'Display image interpolated to match the primary volume'}...
    {'dispCorrelation',0,'type=pushbutton','callback',@dispCorrelation,'buttonString','Display correlation','callbackArg',sysNum,'Display correlation between aligned volume images'}...
    {'initFromHeader',0,'type=pushbutton','callback',@adjustAlignment,'buttonString','Init from header','callbackArg',{sysNum 'initFromHeader'},'passParams=1','Reinit the alignment using the qform/sform info from the headers'}...
    {'setToIdentity',0,'type=pushbutton','callback',@adjustAlignment,'buttonString','Set to identity','callbackArg',{sysNum 'setToIdentity'},'passParams=1','Set the alignment to identity'}...
    {'swapXY',0,'type=pushbutton','callback',@adjustAlignment,'buttonString','Swap XY','callbackArg',{sysNum 'swapXY'},'passParams=1','Swap XY in the alignment'}...
    {'swapXZ',0,'type=pushbutton','callback',@adjustAlignment,'buttonString','Swap XZ','callbackArg',{sysNum 'swapXZ'},'passParams=1','Swap XZ in the alignment'}...
    {'swapYZ',0,'type=pushbutton','callback',@adjustAlignment,'buttonString','Swap YZ','callbackArg',{sysNum 'swapYZ'},'passParams=1','Swap YZ in the alignment'}...
    {'flipX',0,'type=pushbutton','callback',@adjustAlignment,'buttonString','Flip X','callbackArg',{sysNum 'flipX'},'passParams=1','Flip X axis in alignment'}...
    {'flipY',0,'type=pushbutton','callback',@adjustAlignment,'buttonString','Flip Y','callbackArg',{sysNum 'flipY'},'passParams=1','Flip Y axis in alignment'}...
    {'flipZ',0,'type=pushbutton','callback',@adjustAlignment,'buttonString','Flip Z','callbackArg',{sysNum 'flipZ'},'passParams=1','Flip Z axis in alignment'}...
    {'shiftX',gVol{sysNum}.xformParams.shiftX,'incdec=[-1 1]','callback',@adjustAlignment,'callbackArg',{sysNum 'shiftX'},'passParams=1','Shift X axis in alignment in units of voxels'}...
    {'shiftY',gVol{sysNum}.xformParams.shiftY,'incdec=[-1 1]','callback',@adjustAlignment,'callbackArg',{sysNum 'shiftX'},'passParams=1','Shift Y axis in alignment in units of voxels'}...
    {'shiftZ',gVol{sysNum}.xformParams.shiftZ,'incdec=[-1 1]','callback',@adjustAlignment,'callbackArg',{sysNum 'shiftX'},'passParams=1','Shift Z axis in alignment in units of voxels'}...
    {'rotateXY',gVol{sysNum}.xformParams.rotateXY,'incdec=[-1 1]','callback',@adjustAlignment,'callbackArg',{sysNum 'rotateXY'},'passParams=1','Rotate in XY plane in units of degrees'}...
    {'rotateXZ',gVol{sysNum}.xformParams.rotateXZ,'incdec=[-1 1]','callback',@adjustAlignment,'callbackArg',{sysNum 'rotateXZ'},'passParams=1','Rotate in XZ plane in units of degrees'}...
    {'rotateYZ',gVol{sysNum}.xformParams.rotateYZ,'incdec=[-1 1]','callback',@adjustAlignment,'callbackArg',{sysNum 'rotateYZ'},'passParams=1','Rotate in YZ plane in units of degrees'}...
    {'vol2vol',gVol{sysNum}.vols(2).xform,'callback',@adjustAlignment,'callbackArg',{sysNum 'vol2vol'},'passParams=1','Directly set the alignment transform - this gets composited with the shift and rotate paramters above'}
	     };
else
  paramsInfo = {...
      {'save',0,'type=pushbutton','callback',@saveVol,'buttonString','Save volume','callbackArg',sysNum,'Save the volume'}...
      {'orient',0,'type=pushbutton','callback',@orientVol,'buttonString','Convert to LPI','callbackArg',sysNum,'Change the volume data to a canonical orientation. Note that this may not change the view in the viewer if the xform information is correct - but the axis labels may change'}...
      {'swapXY',0,'type=pushbutton','callback',@adjustVol,'buttonString','Swap XY','callbackArg',{sysNum 'swapXY'},'passParams=1','Swap XY of volume. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'swapXZ',0,'type=pushbutton','callback',@adjustVol,'buttonString','Swap XZ','callbackArg',{sysNum 'swapXZ'},'passParams=1','Swap XZ of volume. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'swapYZ',0,'type=pushbutton','callback',@adjustVol,'buttonString','Swap YZ','callbackArg',{sysNum 'swapYZ'},'passParams=1','Swap YZ of volume. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'flipX',0,'type=pushbutton','callback',@adjustVol,'buttonString','Flip X','callbackArg',{sysNum 'flipX'},'passParams=1','Flip X axis of volume. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'flipY',0,'type=pushbutton','callback',@adjustVol,'buttonString','Flip Y','callbackArg',{sysNum 'flipY'},'passParams=1','Flip Y axis of volume. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'flipZ',0,'type=pushbutton','callback',@adjustVol,'buttonString','Flip Z','callbackArg',{sysNum 'flipZ'},'passParams=1','Flip Z axis of volume. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'shiftX',0,'incdec=[-1 1]','callback',@adjustVol,'callbackArg',{sysNum 'shiftX'},'passParams=1','Shift X axis of volume in units of voxels. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'shiftY',0,'incdec=[-1 1]','callback',@adjustVol,'callbackArg',{sysNum 'shiftX'},'passParams=1','Shift Y axis of volume in units of voxels. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'shiftZ',0,'incdec=[-1 1]','callback',@adjustVol,'callbackArg',{sysNum 'shiftX'},'passParams=1','Shift Z axis of volume in units of voxels. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'rotateXY',0,'incdec=[-1 1]','callback',@adjustVol,'callbackArg',{sysNum 'rotateXY'},'passParams=1','Rotate in XY plane in units of degrees. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'rotateXZ',0,'incdec=[-1 1]','callback',@adjustVol,'callbackArg',{sysNum 'rotateXZ'},'passParams=1','Rotate in XZ plane in units of degrees. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'rotateYZ',0,'incdec=[-1 1]','callback',@adjustVol,'callbackArg',{sysNum 'rotateYZ'},'passParams=1','Rotate in YZ plane in units of degrees. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'xMin',1,'incdec=[-1 1]','minmax',[1 gVol{sysNum}.vols(1).h.dim(1)],'callback',@adjustVol,'callbackArg',{sysNum 'xMin'},'passParams=1','round=1','Crop the image in the x dimension. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'xMax',inf,'incdec=[-1 1]','minmax',[1 gVol{sysNum}.vols(1).h.dim(1)],'callback',@adjustVol,'callbackArg',{sysNum 'xMax'},'passParams=1','round=1','Crop the image in the x dimension. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'yMin',1,'incdec=[-1 1]','minmax',[1 gVol{sysNum}.vols(1).h.dim(2)],'callback',@adjustVol,'callbackArg',{sysNum 'yMin'},'passParams=1','round=1','Crop the image in the y dimension. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'yMax',inf,'incdec=[-1 1]','minmax',[1 gVol{sysNum}.vols(1).h.dim(2)],'callback',@adjustVol,'callbackArg',{sysNum 'yMax'},'passParams=1','round=1','Crop the image in the y dimension. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'zMin',1,'incdec=[-1 1]','minmax',[1 gVol{sysNum}.vols(1).h.dim(3)],'callback',@adjustVol,'callbackArg',{sysNum 'zMin'},'passParams=1','round=1','Crop the image in the z dimension. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'zMax',inf,'incdec=[-1 1]','minmax',[1 gVol{sysNum}.vols(1).h.dim(3)],'callback',@adjustVol,'callbackArg',{sysNum 'zMax'},'passParams=1','round=1','Crop the image in the z dimension. Hold down shift while clicking this to only apply xform to image and not to header.'}...
	       };
end

% add ability to change display of alternate coordinates
altXforms = gVol{sysNum}.vols(1).altXforms;
if altXforms.n 
  paramsInfo{end+1} = {'altCoord',putOnTopOfList(altXforms.names{altXforms.currentXform},altXforms.names),'callback',@changeAltCoord,'callbackArg',sysNum,'passParams=1'};
end
if isfield(gVol{sysNum}.vols(1),'complexData')
  paramsInfo{end+1} = {'dispComplex',putOnTopOfList(gVol{sysNum}.dispComplex,{'magnitude','phase','fft2 magnitude','fft2 phase','fft3 magnitude','fft3 phase'}),'callback',@dispComplex,'callbackArg',sysNum,'passParams=1','Change how complex data is displayed'};
end
%mrParamsDialog(paramsInfo,'mlrVol Controls',[],@controlsCallback);
mrParamsDialog(paramsInfo,'mlrVol Controls');

%%%%%%%%%%%%%%%%%%%
%    adjustVol    %
%%%%%%%%%%%%%%%%%%%
function retval = adjustVol(args,params)

% return argument for mrParams
retval = 1;

global gVol;
sysNum = args{1};

% get command name and value
commandName = args{2};
commandValue = params.(commandName);

% see if shift key is down, in whcih case we don't apply to header
if any(strcmp(get(gcf,'CurrentModifier'),'shift'))
  disp(sprintf('(mlrVol:adjustVol) Only applying %s to image data not header',commandName));
  applyToHeader = 0;
else
  if ~gVol{sysNum}.imageOrientation
    oneTimeWarning('mlrVolAdjustDims','(mlrVol:adjustDims) Note that when you apply a transformation, the same transformation gets applied to the header xform and mlrVol will adjust the display to compensate (so for example if you swap XY it will swap the labels of the axis, but not necessarily what is being displayed). If instead you want to swap the data but NOT the header xform, then hold down the shift key as you make the adjustments');
  end
  applyToHeader = 1;
end

% do the command
[gVol{sysNum}.vols(1).data gVol{sysNum}.vols(1).h] = mlrImageXform(gVol{sysNum}.vols(1).data,gVol{sysNum}.vols(1).h,commandName,commandValue,'applyToHeader',applyToHeader);

% update the axis info
gVol{sysNum}.vols(1) = updateVolAxisInfo(sysNum,gVol{sysNum}.vols(1),gVol{sysNum}.vols(1).h);
setVolCoord(sysNum,1,gVol{sysNum}.vols(1).coord);

% redisplay
gVol{sysNum}.vols.curCoord(:) = nan;
refreshDisplay(sysNum);

% clear the parameter
if any(strcmp(commandName,{'xMax','yMax','zMax'}))
  params.(commandName) = inf;
else
  params.(commandName) = 0;
end
  
mrParamsSet(params);

%%%%%%%%%%%%%%%%%%%
%    orientVol    %
%%%%%%%%%%%%%%%%%%%
function retval = orientVol(sysNum)

% return argument for mrParams
retval = [];

global gVol;

% get what orientation the image is
axisLabels = mlrImageGetAxisLabels(gVol{sysNum}.vols(1).h.qform);

% put up a dialog box so user can select the orientation to save to
paramsInfo = {...
    {'currentOrientation',axisLabels.orient,'editable=0','This is the orientation that the volume is in'},...
    {'desiredOrientation','LPI','Set this to whatever orientation you want as specified by the three letter string which can be composed of L for left or R for right and A for anterior or P for Posterior and S for superior and I for inferior.'}...
	     };
params = mrParamsDialog(paramsInfo,'Choose desired orientation');
if isempty(params),return,end

% orient the voliume in LPI
[gVol{sysNum}.vols(1).data gVol{sysNum}.vols(1).h] = mlrImageOrient(params.desiredOrientation,gVol{sysNum}.vols(1).data,gVol{sysNum}.vols(1).h);

% update the axis info
gVol{sysNum}.vols(1) = updateVolAxisInfo(sysNum,gVol{sysNum}.vols(1),gVol{sysNum}.vols(1).h);
setVolCoord(sysNum,1,gVol{sysNum}.vols(1).coord);

% redisplay
gVol{sysNum}.vols.curCoord(:) = nan;
refreshDisplay(sysNum);

%%%%%%%%%%%%%%%%%
%    saveVol    %
%%%%%%%%%%%%%%%%%
function retval = saveVol(sysNum)

% return argument for mrParams
retval = [];

global gVol;
vol = gVol{sysNum}.vols(1);

% get directory to start save box in
[filename pathname ] = uiputfile({'*.hdr;*.img;*.nii','Nifti format';'*.sdt;*.spr;*.edt*.epr','BSI stimulate format'},'Save volume',vol.h.filename);
if isequal(filename,0),return,end

mlrImageSave(fullfile(pathname,filename),vol.data,vol.h);

%%%%%%%%%%%%%%%%%%%%%%%%
%    changeAltCoord    %
%%%%%%%%%%%%%%%%%%%%%%%%
function retval = changeAltCoord(sysNum,params)

global gVol;
altXforms = gVol{sysNum}.vols(1).altXforms;

% find the current matching number and set it
gVol{sysNum}.vols(1).altXforms.currentXform = first(find(strcmp(params.altCoord,altXforms.names)));
shortName = altXforms.shortNames{gVol{sysNum}.vols(1).altXforms.currentXform};

% set the short names
set(gVol{sysNum}.hExtraCoordTitle(1),'String',sprintf('%s X',shortName));
set(gVol{sysNum}.hExtraCoordTitle(2),'String',sprintf('%s Y',shortName));
set(gVol{sysNum}.hExtraCoordTitle(3),'String',sprintf('%s Z',shortName));
updateExtraCoords(sysNum);

retval = [];

%%%%%%%%%%%%%%%%%%%%%%%%%%
%    controlsCallback    %
%%%%%%%%%%%%%%%%%%%%%%%%%%
function controlsCallback(params)


%%%%%%%%%%%%%%%%%%%%%
%    dispComplex    %
%%%%%%%%%%%%%%%%%%%%%
function retval = dispComplex(sysNum,params)

global gVol;

% go through all volumes
for iVol = gVol{sysNum}.n
  % if it is complex data then reset its data value
  % to display chosen field
  if isfield(gVol{sysNum}.vols(iVol),'complexData');
    switch (params.dispComplex)
     case {'magnitude'}
      gVol{sysNum}.vols(iVol).data = abs(gVol{sysNum}.vols(iVol).complexData);
     case {'phase'}
      gVol{sysNum}.vols(iVol).data = angle(gVol{sysNum}.vols(iVol).complexData);
     case {'fft2 magnitude','fft2 phase'}
      % nDims hard coded to 5 here
      disppercent(-inf,'(mlrVol) Transforming data');
      nSlice = size(gVol{sysNum}.vols(iVol).data,3);
      nVolume = size(gVol{sysNum}.vols(iVol).data,4);
      nReceiver = size(gVol{sysNum}.vols(iVol).data,5);
      for iSlice = 1:nSlice
	for iVolume = 1:nVolume
	  for iReceiver = 1:nReceiver
	    % take fft
	    fftSlice = fftshift(fft2(gVol{sysNum}.vols(iVol).complexData(:,:,iSlice,iVolume,iReceiver)));
	    % get phase or magnitude
	    if strcmp(params.dispComplex,'fft2 phase')
	      gVol{sysNum}.vols(iVol).data(:,:,iSlice,iVolume,iReceiver) = angle(fftSlice);
	    else
	      gVol{sysNum}.vols(iVol).data(:,:,iSlice,iVolume,iReceiver) = abs(fftSlice);
	    end
	    % percent correct
	    disppercent(calcPercentDone(iSlice,nSlice,iVolume,nVolume,iReceiver,nReceiver));
	  end
	end
      end
      disppercent(inf);
     case {'fft3 magnitude','fft3 phase'}
      % nDims hard coded to 5 here
      disppercent(-inf,'(mlrVol) Transforming data');
      nVolume = size(gVol{sysNum}.vols(iVol).data,4);
      nReceiver = size(gVol{sysNum}.vols(iVol).data,5);
      for iVolume = 1:nVolume
	for iReceiver = 1:nReceiver
	  % take fft
	  fftVolume = fftshift(fftn(squeeze(gVol{sysNum}.vols(iVol).complexData(:,:,:,iVolume,iReceiver))));
	  % and get phase or magnitude
	  if strcmp(params.dispComplex,'fft3 phase')
	    gVol{sysNum}.vols(iVol).data(:,:,:,iVolume,iReceiver) = angle(fftVolume);
	  else
	    gVol{sysNum}.vols(iVol).data(:,:,:,iVolume,iReceiver) = abs(fftVolume);
	  end
	  % percent done
	  disppercent(calcPercentDone(iVolume,nVolume,iReceiver,nReceiver));
	end
      end
      disppercent(inf);
    end      
    % clear cache
    gVol{sysNum}.vols(iVol).c = mrCache('init',2*max(gVol{sysNum}.vols(iVol).h.dim(1:3)));
    % and set to redisplay
    gVol{sysNum}.vols(iVol).curCoord(1:3) = nan;
  end
end

% set what value we are looking at
gVol{sysNum}.dispComplex = params.dispComplex;

% redisplay
refreshDisplay(sysNum);

%%%%%%%%%%%%%%%%%%%%%%%%%
%    adjustAlignment    %
%%%%%%%%%%%%%%%%%%%%%%%%%
function retval = adjustAlignment(args,params)

% some variables
global gVol;
retval = [];
sysNum = args{1};
command = args{2};
replaceXform = false;
changeXform = true;
verbose = gVol{sysNum}.verbose;

% get system xform
gVol{sysNum}.xformParams = params;
%gVol{sysNum}.xform = [1 0 0 params.shiftX;0 1 0 params.shiftY;0 0 1 params.shiftZ; 0 0 0 1];
% make rotation matrix, but need to rotate around center coordinates
dim = gVol{sysNum}.vols(2).h.dim;
shiftToCenterOfVol = makeRotMatrix3D(0,0,0,-[dim(1)/2 dim(2)/2 dim(3)/2]);
gVol{sysNum}.xform = inv(shiftToCenterOfVol) * makeRotMatrix3D(params.rotateXZ,params.rotateYZ,params.rotateXY,[params.shiftX params.shiftY params.shiftZ],1)*shiftToCenterOfVol;


% get the necessary xform
switch args{2}
 case {'swapXY'}
  xform = [0 1 0 0;1 0 0 0;0 0 1 0;0 0 0 1];
 case {'swapXZ'}
  xform = [0 0 1 0;0 1 0 0;1 0 0 0;0 0 0 1];
 case {'swapYZ'}
  xform = [1 0 0 0;0 0 1 0;0 1 0 0;0 0 0 1];
 case {'flipX'}
  % set the xform - the nan will get set to the image size below
  xform = [-1 0 0 nan;0 1 0 0;0 0 1 0; 0 0 0 1];
 case {'flipY'}
  xform = [1 0 0 0;0 -1 0 nan;0 0 1 0; 0 0 0 1];
 case {'flipZ'}
  xform = [1 0 0 0;0 1 0 0;0 0 -1 nan; 0 0 0 1];
 case {'shiftX','shiftY','shiftZ','rotateXY','rotateXZ','rotateYZ'}
  changeXform = false;
 case {'initFromHeader'}
  xform = getVol2vol(sysNum,gVol{sysNum}.vols(2),gVol{sysNum}.vols(1));
  replaceXform = true;
 case {'vol2vol'}
  xform = params.vol2vol;
  replaceXform = true;
 case {'setToIdentity'}
  xform = eye(4);
  replaceXform = true;
end

% set the transform
for iVol = 1:gVol{sysNum}.n
  if verbose,dispHeader;end
  if gVol{sysNum}.vols(iVol).tethered
    if changeXform
      % see if there is a nan that needs to be replaced
      [row col] = find(isnan(xform));
      if ~isempty(row)
	% replace from the appropriate coordinate
	val = gVol{sysNum}.vols(iVol).h.dim(row);
	thisXform = xform;
	thisXform(row,col) = val;
      else
	thisXform = xform;
      end
      if ~replaceXform
	% display what we are doing
	if verbose,disp(sprintf('(mlrVol) Compositing xform\n%s',mrnum2str(thisXform,'compact=0','sigfigs=-1')));end
        % now set the xform
	gVol{sysNum}.vols(iVol).xform = gVol{sysNum}.vols(iVol).xform*thisXform;
      else
	gVol{sysNum}.vols(iVol).xform = xform;
      end
    end
    if verbose
      % display what we are doing
      disp(sprintf('(mlrVol) xform\n%s',mrnum2str(gVol{sysNum}.vols(iVol).xform,'compact=0','sigfigs=-1')));
      % display system xform
      disp(sprintf('(mlrVol) System xform\n%s',mrnum2str(gVol{sysNum}.xform,'compact=0','sigfigs=-1')));
      % display complete xform
      disp(sprintf('(mlrVol) xform after compositing system\n%s',mrnum2str(shiftOriginXform*applySystemXform(sysNum,gVol{sysNum}.vols(iVol).xform)*inv(shiftOriginXform),'compact=0','sigfigs=-1')));
    end
    % clear cache
    gVol{sysNum}.vols(iVol).c = mrCache('init',2*max(gVol{sysNum}.vols(iVol).h.dim(1:3)));
    % update the dialog box
    updateParams.vol2vol = gVol{sysNum}.vols(iVol).xform;
    mrParamsSet(updateParams);
  end
  % set all images to redisplay
  gVol{sysNum}.vols(iVol).curCoord(1:3) = nan;
end

% set the altXform for displaying coordinates of the transformed volume
altXforms = gVol{sysNum}.vols(1).altXforms;
% get the aligned volume alternate xform
altXformNum = find(strcmp('Aligned volume',altXforms.names));
if ~isempty(altXformNum)
  gVol{sysNum}.vols(1).altXforms.xforms{altXformNum} = applySystemXform(sysNum,gVol{sysNum}.vols(iVol).xform);
end

% redisplay
refreshDisplay(sysNum);

%%%%%%%%%%%%%%%%%%%%%%
%    overlayAlpha    %
%%%%%%%%%%%%%%%%%%%%%%
function retval = overlayAlpha(sysNum,params)

global gVol;
gVol{sysNum}.overlayAlpha = params.overlayAlpha;

% go through volumes
for iVol = 1:gVol{sysNum}.n
  % for each tethered
  if gVol{sysNum}.vols(iVol).tethered
    % go through each view and toggle alpha
    for iView = 1:3
      alphaData = get(gVol{sysNum}.vols(iVol).overlay(iView),'AlphaData');
      mask = gVol{sysNum}.vols(iVol).overlayMask{iView};
      alphaData(mask) = gVol{sysNum}.overlayAlpha;
      set(gVol{sysNum}.vols(iVol).overlay(iView),'AlphaData',alphaData);
    end
  end
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    dispCorrelation    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function retval = dispCorrelation(sysNum)

f = gcf;

retval = [];
global gVol;

% get the two volumes
vol1 = gVol{sysNum}.vols(1);
vol2 = gVol{sysNum}.vols(2);

% open figure
if ~isfield(gVol{sysNum},'dispCorrelationFig') || isempty(gVol{sysNum}.dispCorrelationFig)
  gVol{sysNum}.dispCorrelationFig = figure;
else
  figure(gVol{sysNum}.dispCorrelationFig);
end
clf;

titleStr = '';
for iView = 1:3
  % grab the data grom the first volume
  % nDims hard coded to 5 here
  dispSlice1 = squeeze(vol1.data(vol1.viewIndexes{iView,1},vol1.viewIndexes{iView,2},vol1.viewIndexes{iView,3},vol1.coord(4),vol1.coord(5)));

  % and get the dispSlice from the tethered volume
  dispSlice2 = vol2.dispSlice{iView};

  % select only non-nan values
  nonnan = find(~isnan(dispSlice1(:)) & ~isnan(dispSlice2(:)));
  dispSlice1 = dispSlice1(nonnan);
  dispSlice2 = dispSlice2(nonnan);
  
  % compute stats
  slope = pinv(dispSlice1(:))*dispSlice2(:);
  r2 = regstats(dispSlice1(:),dispSlice2(:),'linear','rsquare');
  r2 = r2.rsquare;
  titleStr = sprintf('%s m=%0.2f r^2:%0.3f',titleStr,slope,r2);
  
  % display
  plot(dispSlice1(:),dispSlice2(:),'.','Color',getSmoothColor(iView,3));
  hold on;
end

% display the labels
title(titleStr);
xlabel(sprintf('%s voxel values',vol1.h.filename));
ylabel(sprintf('%s voxel values',vol2.h.filename));

% set the axis equal
%[xmin xmax] = xaxis;
%[ymin ymax] = yaxis;
%axis([min(xmin,ymin) max(xmax,ymax) min(xmin,ymin) max(xmax,ymax)]);

% put up diagonal
dline('k',1);

% switch back current fig
figure(f);

%%%%%%%%%%%%%%%%%%%%%%%
%    toggleOverlay    %
%%%%%%%%%%%%%%%%%%%%%%%
function retval = toggleOverlay(sysNum)

retval = [];
global gVol;

% go through volumes
for iVol = 1:gVol{sysNum}.n
  % for each tethered
  if gVol{sysNum}.vols(iVol).tethered
    % go through each view and toggle alpha
    for iView = 1:3
      alphaData = get(gVol{sysNum}.vols(iVol).overlay(iView),'AlphaData');
      mask = gVol{sysNum}.vols(iVol).overlayMask{iView};
      if alphaData(first(find(mask)))==0
	gVol{sysNum}.overlayToggleState = 1;
	alphaData(mask) = gVol{sysNum}.overlayAlpha;
	set(gVol{sysNum}.vols(iVol).overlay(iView),'AlphaData',alphaData);
      else
	alphaData(mask) = 0;
	gVol{sysNum}.overlayToggleState = 0;
	set(gVol{sysNum}.vols(iVol).overlay(iView),'AlphaData',alphaData);
      end	  
    end
  end
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   displayInterpolated   %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function displayInterpolated(sysNum,params)

global gVol;

% set the displayInterpolated state
gVol{sysNum}.displayInterpolated = params.displayInterpolated;

% set volumes to redisplay
for iVol = 1:gVol{sysNum}.n
  gVol{sysNum}.vols(iVol).curCoord(1:3) = nan;
end
gVol{sysNum}.vols(2).coord(1:3) = nan;

% and redisplay
refreshDisplay(sysNum);


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    Init functions (initSystem and loadVolume)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%
%    initSystem    %
%%%%%%%%%%%%%%%%%%%%
function [sysNum imageArgs] = initSystem(args)

% default return arguments
sysNum = [];imageArgs = [];

% split into image and arguments
[imageArgs otherArgs] = mlrImageParseArgs(args);

% check to see if there are any valid images
validImages = false;
for i = 1:length(imageArgs)
  if mlrImageIsImage(imageArgs{i})
    validImages = true;
  end
end
if ~validImages,return,end
  
%init global
global gVol;
if isempty(gVol)
  sysNum = 1;
else
  sysNum = length(gVol)+1;
end

% number of loaded volumes
gVol{sysNum}.n = 0;

% parse args here when we have settings
imageOrientation = [];verbose = [];
getArgs(otherArgs,{'imageOrientation=0','verbose=1'});
gVol{sysNum}.imageOrientation = imageOrientation;
gVol{sysNum}.verbose = verbose;

% defaults for button sizes
gVol{sysNum}.buttonWidth = 100;
gVol{sysNum}.buttonWidthMargin = 20;
gVol{sysNum}.buttonHeightMargin = 2;
gVol{sysNum}.buttonHeight = 25;
gVol{sysNum}.buttonLeftMargin = 10;
gVol{sysNum}.buttonBottomMargin = 10;

% get location of figure
figloc = mrGetFigLoc('mlrVol');

% open the fig
gVol{sysNum}.fig(1) = figure;
if ~isempty(figloc)
  set(gVol{sysNum}.fig(1),'Position',figloc);
end
gVol{sysNum}.fig(2) = gVol{sysNum}.fig(1);
gVol{sysNum}.fig(3) = gVol{sysNum}.fig(1);
clf;

% set the mouse functions
set(gVol{sysNum}.fig(1),'WindowButtonDownFcn',sprintf('mlrVol(1,%i)',sysNum));
set(gVol{sysNum}.fig(1),'WindowButtonMotionFcn',sprintf('mlrVol(2,%i)',sysNum));
set(gVol{sysNum}.fig(1),'CloseRequestFcn',sprintf('mlrVol(6,%i)',sysNum));

% set up the axis
gVol{sysNum}.a(1) = subplot(1,3,1);cla;axis off;
gVol{sysNum}.a(2) = subplot(1,3,2);cla;axis off;
gVol{sysNum}.a(3) = subplot(1,3,3);cla;axis off;
gVol{sysNum}.subplotRows = [1 1 1];
gVol{sysNum}.subplotCols = [3 3 3];

% no animation is running
gVol{sysNum}.animating = false;

% get interp method
gVol{sysNum}.interpMethod = mrGetPref('interpMethod');

% alpha for overlay
gVol{sysNum}.overlayAlpha = 0.2;

% default not to display controls
gVol{sysNum}.displayControls = false;

% default system transform
gVol{sysNum}.xform = eye(4);

% overlay toggle state starts as on
gVol{sysNum}.overlayToggleState = 1;

% set up system params
gVol{sysNum}.xformParams.shiftX = 0;
gVol{sysNum}.xformParams.shiftY = 0;
gVol{sysNum}.xformParams.shiftZ = 0;
gVol{sysNum}.xformParams.rotateXY = 0;
gVol{sysNum}.xformParams.rotateXZ = 0;
gVol{sysNum}.xformParams.rotateYZ = 0;

% display the tethered volume interpolated to
% match the primary volume display
gVol{sysNum}.displayInterpolated = true;

% update display
drawnow

%%%%%%%%%%%%%%%%%%%%
%    loadVolume    %
%%%%%%%%%%%%%%%%%%%%
function tf = loadVolume(filename,sysNum)

tf = false;
global gVol;

% display header
if gVol{sysNum}.verbose
  tic
  dispHeader(sprintf('Loading image: %s',mlrImageArgFilename(filename)));
end

% load image
[d h] = mlrImageLoad(filename,'verbose',gVol{sysNum}.verbose);
if isempty(d) || ~mlrImageIsHeader(h),return,end

% make 2D images into nominal 3D
if h.nDim==2
  h.nDim = 3;
  h.dim(3) = 1;
  h.pixdim(3)  = 1;
end

% updated number of volumes
gVol{sysNum}.n = gVol{sysNum}.n+1;
n = gVol{sysNum}.n;

% set volume number
vol.volnum = n;

% set the fields of the volume, if this is compex then split into abs and angle
if isreal(d)
  vol.data = d;
else
  gVol{sysNum}.dispComplex = 'magnitude';
  vol.complexData = d;
  vol.data = abs(d);
end
vol.h = h;

% set which figure numbers this volume will display into
vol.fig(1:3) = gVol{sysNum}.fig(1:3);

% set which subplot
vol.subplotNum(1:3) = (1:3)+(n-1)*3;

% update the axis information for this vol
% this sets how the image will be displayed
vol = updateVolAxisInfo(sysNum,vol,h);

% set the coordinate (start displaying in middle of volume)
coord = round(h.dim/2);
% nDims hard coded to 5 here
coord(end+1:5) = 1;

% set the current coordinates for the first time
vol.curCoord = [nan nan nan];

% print out the header of the image
dispHeaderInfo(sysNum,vol);

% see what other transforms we have
vol.altXforms.shortNames = {};
vol.altXforms.names = {};
vol.altXforms.xforms = {};
vol.altXforms.n = 0;
vol.altXforms.currentXform = [];
if ~isempty(h.vol2tal) && ~isempty(h.vol2mag) && ~isempty(h.sform)
  vol.altXforms.names{end+1} = 'Talairach';
  vol.altXforms.shortNames{end+1} = 'Tal';
  vol.altXforms.xforms{end+1} = h.vol2tal * inv(h.vol2mag) * h.sform * shiftOriginXform;
  vol.altXforms.n = vol.altXforms.n+1;
end
if ~isempty(h.vol2mag)
  vol.altXforms.names{end+1} = 'Canonical magnet';
  vol.altXforms.shortNames{end+1} = 'Mag';
  vol.altXforms.xforms{end+1} = h.vol2mag  * shiftOriginXform;
  vol.altXforms.n = vol.altXforms.n+1;
end
if ~isempty(h.qform)
  vol.altXforms.names{end+1} = 'Qform';
  vol.altXforms.shortNames{end+1} = 'Mag';
  vol.altXforms.xforms{end+1} = h.qform * shiftOriginXform;
  vol.altXforms.n = vol.altXforms.n+1;
end

% set the text boxes
if n == 1
  names = {'X','Y','Z','Volume','Receiver'};
  for i = 1:h.nDim
    % make the inc/dec textboxes
    gVol{sysNum}.hCoordTextbox(i) = makeTextboxIncDec(sysNum,coord(i),i,1,i);
    % get name for button
    if i <= length(names)
      name = names{i};
    else 
      name = sprintf('dim %i',i);
    end
    % make the button
    gVol{sysNum}.hButton(i) = makeButton(sysNum,name,i,2,i);
  end
  % make a text box for the value of the voxel
  makeTextbox(sysNum,'Value',2,h.nDim+1);
  gVol{sysNum}.hValTextbox(1) = makeTextbox(sysNum,'',1,h.nDim+1);

  % make the extra coordinates text boxes
  if vol.altXforms.n > 0
    vol.altXforms.currentXform = 1;
    makeExtraCoordControls(sysNum,vol.altXforms.shortNames{vol.altXforms.currentXform},h.nDim+2);
  end
end

% add another row for displaying the image
if n > 1
  % mark that the volume display is "tethered" to the first volume
  vol.tethered = 1;
  % make a cache for storing images
  vol.c = mrCache('init',2*max(vol.h.dim(1:3)));
  % set the initial transform
  vol.xform = getVol2vol(sysNum,vol,gVol{sysNum}.vols(1));
  % add this to the altXforms
  gVol{sysNum}.vols(1).altXforms.names{end+1} = 'Aligned volume';
  gVol{sysNum}.vols(1).altXforms.shortNames{end+1} = 'Vol';
  gVol{sysNum}.vols(1).altXforms.xforms{end+1} = applySystemXform(sysNum,vol.xform);
  gVol{sysNum}.vols(1).altXforms.n = vol.altXforms.n+1;
  % set alt coord to this one
  params.altCoord = 'Aligned volume';
  % this will make the extra coord controls only if they haven't already been made
  makeExtraCoordControls(sysNum,'',gVol{sysNum}.vols(1).h.nDim+2);
  changeAltCoord(sysNum,params);
  
  % setup subplotRows and subplotCols
  gVol{sysNum}.subplotRows = [n n n];
  gVol{sysNum}.subplotCols = [3 3 3];
  % redo the subplots
  for i = 1:n
    for j = 1:3
      gVol{sysNum}.a(i,j) = subplot(n,3,j+(i-1)*3);
      cla;
      axis off;
    end
  end
  % set to display controls
%  gVol{sysNum}.displayControls = true;
else
  % first volume is displayed independently
  vol.tethered = 0;
  % make close button
  makeButton(sysNum,'Close',-1,4,1);
  makeButton(sysNum,'Controls',-2,3,1);
  % set some fields to empty
  vol.c = [];
  vol.xform = [];
end

% place some empty fields that will get filled by setVolCoord
vol.coord = [];
vol.viewIndexes = {};

% short filename for displaying
vol.name = getLastDir(vol.h.filename);

% set the vol
gVol{sysNum}.vols(n) = vol;

% now set the coordinate in this created volume
setVolCoord(sysNum,n,coord);

% display header
if gVol{sysNum}.verbose
  dispHeader(sprintf('%s loaded (%s)',mlrImageArgFilename(filename),mlrDispElapsedTime(toc)));
end

tf = true;

%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    updateVolAxisInfo    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%
function vol = updateVolAxisInfo(sysNum,vol,h)

global gVol;

% compute magnet directions of each axis based on qform and then
% choose which axis will be displayed in what figure based on this
% information
if ~isempty(h.qform) && ~gVol{sysNum}.imageOrientation
%  [axisLabels vol.axisDirLabels vol.axisMapping axisReverseMapping vol.axisDir] = mlrImageGetAxisLabels(h.qform);
  axisLabels = mlrImageGetAxisLabels(h.qform);
  vol.axisDirLabels = axisLabels.dirLabels;
  vol.axisMapping = axisLabels.mapping;
  vol.axisDir = axisLabels.dir;
  vol.viewDim(1:3) = axisLabels.reverseMapping;
else
  vol.axisDirLabels = [];
  % default to assuming LPI orientation
  vol.axisMapping = [1 2 3];
  vol.axisDir = [1 1 1];
  % no information about what axis is what, so just show each axis in order
  vol.viewDim(1:3) = 1:3;
end

% for convenience set which dimension is x and y for each of the views
% given the viewDim info set above and also info about transposing and flipping
desiredAxis = {[2 3],[1 3],[1 2]};
for iView = 1:3
  % get what the other axis are
  otherDims = setdiff(1:3,vol.viewDim(iView));
  vol.xDim(iView) = otherDims(1);
  vol.yDim(iView) = otherDims(2);
  % next figure out the apporpriate transpose and flips needed to
  % show the images in standard LPI (i.e. the first view will
  % be sagittal with nose to right, second view will be coronal and
  % third view will be axial) all with left is left, right is right
  if vol.axisMapping(otherDims(1)) == desiredAxis{iView}(1)
    % transpose when the desired axis is the same (since
    % images are displayed as y/x by matlab)
    vol.transpose(iView) = 1;
  else
    vol.transpose(iView) = 0;
  end
end

% now make axis labels that can be used for displaying. Note that
% if the axis are flipped, dispSlice will unflip them so we
% have to reverse the order of the labels provided by mlrImageGetAxisLabels
for axisNum = 1:3
  axisLabel = {'X','Y','Z'};
  if isempty(vol.axisDirLabels)
    % no transform, so just use simple X,Y,Z labels
    vol.dispAxisLabels{axisNum} = axisLabel{axisNum};
  else
    % check axis direction
    if vol.axisDir(axisNum) == -1
      % and make reversed labels
      vol.dispAxisLabels{axisNum} = sprintf('%s <- %s -> %s',vol.axisDirLabels{axisNum}{2},axisLabel{axisNum},vol.axisDirLabels{axisNum}{1});
    else
      % and make normal labels
      vol.dispAxisLabels{axisNum} = sprintf('%s <- %s -> %s',vol.axisDirLabels{axisNum}{1},axisLabel{axisNum},vol.axisDirLabels{axisNum}{2});
    end
  end
end

