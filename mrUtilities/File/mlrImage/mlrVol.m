% mlrVol.m
%
%        $Id:$ 
%      usage: mlrVol(filename,<filename2>,'imageOrientation=0')
%         by: justin gardner
%       date: 08/15/11
%    purpose: Volume viewer to display volume multi-dimensional data (usually 3D volumes or 4D epi sequences)
%
%             You can load using filenames, view/scanNum/groupNum,
%             select from a dialog box in the current or canonical
%             directory, or from a struct -> see mlrImageParseArgs
%             for details.
%
%             If qform information exists (from a nifti header) it will orient the axis in LPI and label axis
%             correctly (left/right, posterior/anterior, inferior/superior). If you want to view the
%             image in its native orientation (i.e. order it is written into the matrix, then set the
%             input argument:
%
%             'imageOrienation=1'
%
%             With two filename arguments, will show the alignment between the two images, using
%             the sforms if they are both set / or the qforms otherwise. If neither one is set
%             will display with an identity alignment. A dialog box allows you to fiddle manually
%             with the alignment
%
%             Other options:
%
%             'verbose=1' Set verbose level, 0 for quiet. 1 for normal. 2 for detailed info.
function retval = mlrVol(varargin)

% check arguments
if nargin < 1
  help mlrVol
  return
end

global gVol;

if ~(isscalar(varargin{1}) && isnumeric(varargin{1}))
  % init the system
  [sysNum imageArgs] = initSystem(varargin);
  if isempty(sysNum),return,end

  % load the volumes
  for i = 1:length(imageArgs)
    loadVolume(imageArgs{i},sysNum);
  end
  % quit if no volumes were loaded
  if ~isfield(gVol{sysNum},'vols'),close(gVol{sysNum}.fig);return,end
  
  % display the volume
  refreshDisplay(sysNum);
  
  % display controls
  if gVol{sysNum}.displayControls,displayControls(sysNum);end
else
  % handle events generated by the GUI
  switch (varargin{1})
   case 1
    mouseDownHandler(varargin{2});
   case 2
    mouseMoveHandler(varargin{2});
   case 3
    textHandler(varargin{2},varargin{3});
   case 4
    incdecHandler(varargin{2},varargin{3},varargin{4});
   case 5
    buttonHandler(varargin{2},varargin{3});
   case 6
    closeHandler(varargin{2});
  end
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    Handlers
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%
%    mouseDownHandler    %
%%%%%%%%%%%%%%%%%%%%%%%%%%
function mouseDownHandler(sysNum)

set(gcf,'Pointer','arrow');
global gVol;
if isempty(gVol{sysNum}) || ~isfield(gVol{sysNum},'vols')
  disp(sprintf('(mlrVol) Mouse down called on incomplete mlrVol figure.'));
%  closeHandler(sysNum);
  return
end
vol = gVol{sysNum}.vols(1);

% stop any ongoing animation
gVol{sysNum}.animating = 0;

% get the mouse pos
coord = getMouseCoord(sysNum);
if isempty(coord),return,end

% and set the volume coordinate
setVolCoord(sysNum,1,coord);

% refresh the display
refreshDisplay(sysNum);

%%%%%%%%%%%%%%%%%%%%%%%%%%
%    mouseMoveHandler    %
%%%%%%%%%%%%%%%%%%%%%%%%%%
function mouseMoveHandler(sysNum)

global gVol;
if isempty(gVol{sysNum}) || ~isfield(gVol{sysNum},'vols')
  disp(sprintf('(mlrVol) Mouse move called on incomplete mlrVol figure.'));
%  closeHandler(sysNum);
  return
end
vol = gVol{sysNum}.vols(1);
f = gVol{sysNum}.fig(1);

% abort if we are not focused on figure
if f ~= gcf,return,end

coord = getMouseCoord(sysNum);
if isempty(coord)
  set(gcf,'Pointer','arrow');
  set(gVol{sysNum}.hCoordTextbox(1),'String',vol.coord(1));
  set(gVol{sysNum}.hCoordTextbox(2),'String',vol.coord(2));
  set(gVol{sysNum}.hCoordTextbox(3),'String',vol.coord(3));
  updateExtraCoords(sysNum);
  % nDims hard coded to 5 here
  set(gVol{sysNum}.hValTextbox(1),'String',vol.data(vol.coord(1),vol.coord(2),vol.coord(3),vol.coord(4),vol.coord(5)));
else
  set(gcf,'Pointer',mlrFullCrosshair);
  set(gVol{sysNum}.hCoordTextbox(1),'String',coord(1));
  set(gVol{sysNum}.hCoordTextbox(2),'String',coord(2));
  set(gVol{sysNum}.hCoordTextbox(3),'String',coord(3));
  updateExtraCoords(sysNum);
  % nDims hard coded to 5 here
  set(gVol{sysNum}.hValTextbox(1),'String',vol.data(coord(1),coord(2),coord(3),coord(4),coord(5)));
end

%%%%%%%%%%%%%%%%%%%%%
%%   textHandler   %%
%%%%%%%%%%%%%%%%%%%%%
function textHandler(sysNum,textboxNum)

global gVol;
vol = gVol{sysNum}.vols(1);

% turn off animation
gVol{sysNum}.animating = 0;

% textboxNums that are negative are the extra coordinates
if textboxNum < 0
  % set coordinate according to extra
  setCoordToExtra(sysNum);
end

% get number of dimensions
nDim = gVol{sysNum}.vols(1).h.nDim;

% get coordinate
for iCoord = 1:nDim
  coord(iCoord) = str2num(get(gVol{sysNum}.hCoordTextbox(iCoord),'String'));
end
coord = round(coord);

if any(coord<1) || any(coord(:)>vol.h.dim(1:nDim)')
  for iCoord = 1:nDim
    set(gVol{sysNum}.hCoordTextbox(1),'String',vol.coord(iCoord));
  end
  return
end

% nDims hard coded to 5 here
coord(end+1:5) = 1;

% set the volume coord
setVolCoord(sysNum,1,coord);

% nDims hard coded to 5 here
vol = gVol{sysNum}.vols(1);
set(gVol{sysNum}.hValTextbox(1),'String',vol.data(vol.coord(1),vol.coord(2),vol.coord(3),vol.coord(4),vol.coord(5)));

% and redisplay
refreshDisplay(sysNum);

%%%%%%%%%%%%%%%%%%%%%%%
%%   incdecHandler   %%
%%%%%%%%%%%%%%%%%%%%%%%
function incdecHandler(textNum,incdec,sysNum)

global gVol;
vol = gVol{sysNum}.vols(1);

% turn off animation
gVol{sysNum}.animating = false;

% get the textbox we are updating. If textNum is less
% than zero we are updating the extra coord textboxes
if textNum > 0
  hTextbox = gVol{sysNum}.hCoordTextbox(textNum);
else
  hTextbox = gVol{sysNum}.hExtraCoordTextbox(-textNum);
end
  
% inc or dec the text box
val = str2num(get(hTextbox,'String'));
val = val+incdec;

% if we are doing an extra coordinate than transform
if (textNum < 0)
  set(hTextbox,'String',val);
  textHandler(sysNum,-1);
elseif (val>=1) && (val<=vol.h.dim(textNum))
  % if we have made a valid change then set it
  set(hTextbox,'String',val);
  % now refresh
  textHandler(sysNum,1);
end

%%%%%%%%%%%%%%%%%%%%%%%
%%   buttonHandler   %%
%%%%%%%%%%%%%%%%%%%%%%%
function buttonHandler(textNum,sysNum)

global gVol;
vol = gVol{sysNum}.vols(1);

% display controls
if textNum < 0
  switch textNum
   case -1
    closeHandler(sysNum);
   case -2
    displayControls(sysNum);
  end
  return
end

% if we are already running the animation, then turn it off
if gVol{sysNum}.animating == textNum
  gVol{sysNum}.animating = 0;
  return
end

% get number of dimensions
nDim = vol.h.nDim;

% start the animation
gVol{sysNum}.animating = textNum;
coord = vol.coord;

% loop that runs the animation
while ~isempty(gVol{sysNum}) && gVol{sysNum}.animating
  % increment coord, go forward for an axis that moves in
  % the positive direction 
  if (textNum > 3) || (vol.axisDir(textNum) == 1)
    coord(textNum) = coord(textNum)+1;
    if coord(textNum) > vol.h.dim(textNum)
      coord(textNum) = 1;
    end
    % and negatively otherwise
  else
    coord(textNum) = coord(textNum)-1;
    if coord(textNum) < 1
      coord(textNum) = vol.h.dim(textNum);
    end
  end
  % set the volume coord
  setVolCoord(sysNum,1,coord);
  % set the text boxes
  for iCoord = 1:nDim
    set(gVol{sysNum}.hCoordTextbox(iCoord),'String',coord(iCoord));
  end
  set(gVol{sysNum}.hValTextbox(1),'String',vol.data(coord(1),coord(2),coord(3),coord(4),coord(5)));
  % and refresh
  refreshDisplay(sysNum);
end
%%%%%%%%%%%%%%%%%%%%%%
%%   closeHandler   %%
%%%%%%%%%%%%%%%%%%%%%%
function closeHandler(sysNum)

global gVol;
if isempty(gVol{sysNum})
  % nothing known, just return
  disp(sprintf('(mlrVol) Close handler called but no figure information present'));
  return
end

% stop any ongoing animation
if isfield(gVol{sysNum},'animating') && gVol{sysNum}.animating
  gVol{sysNum}.animating = 0;
end

% close correlation figure if it exists
if isfield(gVol{sysNum},'dispCorrelationFig') && ishandle(gVol{sysNum}.dispCorrelationFig)
  close(gVol{sysNum}.dispCorrelationFig);
end

if isfield(gVol{sysNum},'fig')
  uniqueFigs = unique(gVol{sysNum}.fig);
  % close the figures
  for i = 1:length(uniqueFigs)
    % get the location of the figure - note that if
    % we ever have multiple figures than we will need to change
    % this code here and in initSystem to have more figlocs saved
    mrSetFigLoc('mlrVol',get(uniqueFigs(i),'Position'));

    % close the figure
    delete(uniqueFigs(i));
  end
end

if isfield(gVol{sysNum},'controlsUp') && gVol{sysNum}.controlsUp
  % remember next time to bring up controls
  mrSetPref('mlrVolDisplayControls',true);
  mrParamsClose;
else
  mrSetPref('mlrVolDisplayControls',false);
end

% remember alpha overlay setting for next time
if isfield(gVol{sysNum},'overlayAlpha')
  mrSetPref('mlrVolOverlayAlpha',gVol{sysNum}.overlayAlpha);
end

% remove the variable
gVol{sysNum} = [];

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    Coordinate display helper functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   updateExtraCoords   %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%
function updateExtraCoords(sysNum)

global gVol
if gVol{sysNum}.vols(1).altXforms.n > 0
  % get the current coord
  coord(1) = str2num(get(gVol{sysNum}.hCoordTextbox(1),'String'));
  coord(2) = str2num(get(gVol{sysNum}.hCoordTextbox(2),'String'));
  coord(3) = str2num(get(gVol{sysNum}.hCoordTextbox(3),'String'));
  coord(4) = 1;
  coord = coord(:);
  
  % get the extra coordinate xform
  xform = gVol{sysNum}.vols(1).altXforms.xforms{gVol{sysNum}.vols(1).altXforms.currentXform};

  % convert
  coord = xform * coord;
  
  % and display
  set(gVol{sysNum}.hExtraCoordTextbox(1),'String',sprintf('%0.1f',coord(1)));
  set(gVol{sysNum}.hExtraCoordTextbox(2),'String',sprintf('%0.1f',coord(2)));
  set(gVol{sysNum}.hExtraCoordTextbox(3),'String',sprintf('%0.1f',coord(3)));
end

%%%%%%%%%%%%%%%%%%%%%%%%%
%%   setCoordToExtra   %%
%%%%%%%%%%%%%%%%%%%%%%%%%
function setCoordToExtra(sysNum)

global gVol;
vol = gVol{sysNum}.vols(1);

% get coordinates form extra textbox
coord(1) = str2num(get(gVol{sysNum}.hExtraCoordTextbox(1),'String'));
coord(2) = str2num(get(gVol{sysNum}.hExtraCoordTextbox(2),'String'));
coord(3) = str2num(get(gVol{sysNum}.hExtraCoordTextbox(3),'String'));
coord(4) = 1;
coord = coord(:);

% get the extra coordinate xform
xform = gVol{sysNum}.vols(1).altXforms.xforms{gVol{sysNum}.vols(1).altXforms.currentXform};

% convert
coord = round(inv(xform) * coord);

% check to see if we have valid coordinates
if all(coord(1:3) > 0) && all(coord(1:3)' <= vol.h.dim(1:3))
  % if so, then display
  set(gVol{sysNum}.hCoordTextbox(1),'String',sprintf('%0.0f',coord(1)));
  set(gVol{sysNum}.hCoordTextbox(2),'String',sprintf('%0.0f',coord(2)));
  set(gVol{sysNum}.hCoordTextbox(3),'String',sprintf('%0.0f',coord(3)));
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   makeExtraCoordControls   %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function makeExtraCoordControls(sysNum,shortName,col)

global gVol;

if ~isfield(gVol{sysNum},'hExtraCoordTitle')
  gVol{sysNum}.hExtraCoordTitle(1) = makeTextbox(sysNum,sprintf('%s X',shortName),2,col);
  gVol{sysNum}.hExtraCoordTextbox(1) = makeTextboxIncDec(sysNum,'',-1,1,col);
  gVol{sysNum}.hExtraCoordTitle(2) = makeTextbox(sysNum,sprintf('%s Y',shortName),2,col+1);
  gVol{sysNum}.hExtraCoordTextbox(2) = makeTextboxIncDec(sysNum,'',-2,1,col+1);
  gVol{sysNum}.hExtraCoordTitle(3) = makeTextbox(sysNum,sprintf('%s Z',shortName),2,col+2);
  gVol{sysNum}.hExtraCoordTextbox(3) = makeTextboxIncDec(sysNum,'',-3,1,col+2);
end

%%%%%%%%%%%%%%%%%%%%%%%
%    getMouseCoord    %
%%%%%%%%%%%%%%%%%%%%%%%
function coord = getMouseCoord(sysNum)

coord = [];viewNum = [];

global gVol;
vol = gVol{sysNum}.vols(1);
f = gVol{sysNum}.fig(1);

% figure out which axis we are on
pointerLoc = get(f,'CurrentPoint');
pos = get(f,'Position');
pos = pointerLoc./pos(3:4);
subplotNum = ceil(pos(1)*3);
if (subplotNum>0) && (subplotNum<=3)
  a = subplot(gVol{sysNum}.subplotRows(1),gVol{sysNum}.subplotCols(1),subplotNum);
else
  return
end
viewNum = find(gVol{sysNum}.a(1,1:3) == a);
if isempty(viewNum),return,end

% get pointer loc
pointerLoc = get(a,'CurrentPoint');
pointerLoc = round(pointerLoc(1,2:-1:1));

% check transpose to see which coordinate is which
% note that matlab displays matrices in a transposed fashion
if ~vol.transpose(viewNum)
  pointerX = pointerLoc(1);
  pointerY = pointerLoc(2);
else
  pointerX = pointerLoc(2);
  pointerY = pointerLoc(1);
end

% check image boundaries 
if (pointerX < 1) | (pointerX > vol.h.dim(vol.xDim(viewNum))),return,end
if (pointerY < 1) | (pointerY > vol.h.dim(vol.yDim(viewNum))),return,end

% get the coordinate. Note that we have to be careful both of whether the axis
% is flipped AND whether there was a transpose (since the y-axis goes in
% the opposite direction as x for matlab displayed images
if ((vol.axisDir(vol.xDim(viewNum)) == 1) && (vol.transpose(viewNum))) || ((vol.axisDir(vol.xDim(viewNum)) == -1) && (~vol.transpose(viewNum)))
  coord(vol.xDim(viewNum)) = pointerX;
else
  coord(vol.xDim(viewNum)) = vol.h.dim(vol.xDim(viewNum)) - pointerX + 1;
end
% note that for the y-dimension, matlab's axis are flipped
if ((vol.axisDir(vol.yDim(viewNum)) == -1) && (vol.transpose(viewNum))) || ((vol.axisDir(vol.yDim(viewNum)) == 1) && (~vol.transpose(viewNum)))
  coord(vol.yDim(viewNum)) = pointerY;
else
  coord(vol.yDim(viewNum)) = vol.h.dim(vol.yDim(viewNum)) - pointerY + 1;
end
coord(vol.viewDim(viewNum)) = vol.coord(vol.viewDim(viewNum));

% nDims hard coded to 5 here
coord(end+1:5) = vol.coord(length(coord)+1:5);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    main display functions (refreshDisplay and dispVolume)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%    refreshDisplay    %
%%%%%%%%%%%%%%%%%%%%%%%%
function refreshDisplay(sysNum)

global gVol;


% get current figure
f = gcf;

% set the figure to the mlrVol figure
figure(gVol{sysNum}.vols(1).fig(1));

% go through each volume
for iVol = 1:gVol{sysNum}.n
  % if the volume is tethered then set its coordinates according
  % to whatever volume it is tethered to.
  if gVol{sysNum}.vols(iVol).tethered
    setTetheredCoord(sysNum,iVol,gVol{sysNum}.vols(iVol).tethered);
  end

  % display the volume
  dispVolume(iVol,sysNum)

  % set that we have displayed this coordinate
  gVol{sysNum}.vols(iVol).curCoord = gVol{sysNum}.vols(iVol).coord;

  % draw
  drawnow
  if isempty(gVol{sysNum}),return,end
end

% update the display of other coordinates
updateExtraCoords(sysNum);

% draw
drawnow;

% and reset figure back to what was current before this call
figure(f);


%%%%%%%%%%%%%%%%%%%%
%    dispVolume    %
%%%%%%%%%%%%%%%%%%%%
function dispVolume(iVol,sysNum)

%if iVol == 2,keyboard,end
global gVol;
vol = gVol{sysNum}.vols(iVol);

% view labels
viewLabel = {'Sagittal','Coronal','Axial'};

for iView = 1:3
  % see if we need to redisplay, first condition is whether we have changed the volume or other dimenson
  % the second condition is for primary volumes whether we have updated the coordinates being displayed
  % in the view, and the third condition is for tethered volumes - whether we have change the coordinates
  % for the volume we are tethered to
  if ((iVol==1) && (~isequal(vol.curCoord(4:end),vol.coord(4:end)) || (~isequal(vol.curCoord(vol.viewDim(iView)),vol.coord(vol.viewDim(iView)))))) || ((iVol~=1) && gVol{sysNum}.refreshView(iView)) || ~gVol{sysNum}.displayInterpolated
    % set to refresh view so that the tethered volumes will be refreshed
    gVol{sysNum}.refreshView(iView) = 1;
    % get the slice
    % nDims hard coded to 5 here
    if vol.tethered
      % tethered volumes have their display slices precomputed (by interpolation) in 
      % setTetheredCoord
      dispSlice = vol.dispSlice{iView};

      % get the axis that we are tethered to (so that we can draw the overlay)
      aTether = subplot(gVol{sysNum}.subplotRows(iView),gVol{sysNum}.subplotCols(iView),gVol{sysNum}.vols(vol.tethered).subplotNum(iView));

      % the transpose and axis directions need to be taken from the volume this is tethered to
      % prepare image for display
      [dispOverlaySlice xLabelStr yLabelStr] = prepareImageForDisplay(sysNum,dispSlice,gVol{sysNum}.vols(vol.tethered),iView);

      % if we are not displaying the interpolated image in the
      % second row, then we have to prepare the image that
      % corresponds to the same location
      if gVol{sysNum}.displayInterpolated
	dispSlice = dispOverlaySlice;
      else
	% need to get the coordinate of the tethered to volume
	% in these coordinates
	dispSlice = getMatchingSlice(sysNum,vol,iView);
	[dispSlice xLabelStr yLabelStr] = prepareImageForDisplay(sysNum,dispSlice,vol,iView);
      end
    else
      % otherwise, grab the data for this image
      dispSlice = squeeze(vol.data(vol.viewIndexes{iView,1},vol.viewIndexes{iView,2},vol.viewIndexes{iView,3},vol.coord(4),vol.coord(5)));

      % prepare image for display
      [dispSlice xLabelStr yLabelStr] = prepareImageForDisplay(sysNum,dispSlice,vol,iView);
    end

    % get the correct axis to draw into
    a = subplot(gVol{sysNum}.subplotRows(iView),gVol{sysNum}.subplotCols(iView),vol.subplotNum(iView));

    % clear the axis
    cla(a);

    % and display the image
    if isempty(dispSlice)
      axis off;
    else
      subimage(dispSlice,gray(256));
      % turn off labels
      set(a,'XTickLabel','');
      set(a,'YTickLabel','');
      % and put on what axis we have
      xlabel(a,xLabelStr);
      ylabel(a,yLabelStr);
    end

    % set title
    titleStr = sprintf('%s: %s (%ix%i)',vol.name,viewLabel{iView},size(dispSlice,2),size(dispSlice,1));
    h = title(titleStr,'Interpreter','none');
    
    % and display the overlay
    if vol.tethered
      % switch to the axis that this volume is tethered to (i.e. draw over the other image)
      axes(aTether);
      hold on;
      % display
      gVol{sysNum}.vols(iVol).overlay(iView) = subimage(dispOverlaySlice,hot(256));
      % set alpha
      gVol{sysNum}.vols(iVol).overlayMask{iView} = ~isnan(dispOverlaySlice(:));
      alphaData = zeros(size(dispOverlaySlice));
      if gVol{sysNum}.overlayToggleState
	alphaData(gVol{sysNum}.vols(iVol).overlayMask{iView}) = gVol{sysNum}.overlayAlpha;
      end
      set(gVol{sysNum}.vols(iVol).overlay(iView),'AlphaData',alphaData);
      hold off;
    end
    
  else
    % set not to refresh this view
    gVol{sysNum}.refreshView(iView) = 0;
  end
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    Helper display functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   getMatchingSlice   %%
%%%%%%%%%%%%%%%%%%%%%%%%%%
function dispSlice = getMatchingSlice(sysNum,vol,iView)

global gVol;

% get coordinated of volume we are tethered to
coord = gVol{sysNum}.vols(vol.tethered).coord;
coord(4) = 1;coord = coord(1:4);coord = coord(:);

% convert to this volume coordinates
coord = round(applyOriginXform(inv(vol.xform))*coord);
coord = coord(1:3);

% FIX: this hardcodes the volume number to 1
coord(end+1:5) = 1;

% check to see if coordinates are in volume
if any(coord(1:3)<1) || any(coord(1:3)'>vol.h.dim(1:3))
  dispSlice = [];
  return
end

% make into a row vector
coord = coord(:)';

% if not set the volume coordinates
setVolCoord(sysNum,vol.volnum,coord);
vol = gVol{sysNum}.vols(vol.volnum);

% and get display slice
dispSlice = squeeze(vol.data(vol.viewIndexes{iView,1},vol.viewIndexes{iView,2},vol.viewIndexes{iView,3},vol.coord(4),vol.coord(5)));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   prepareImageForDisplay   %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [dispSlice xLabelStr yLabelStr] = prepareImageForDisplay(sysNum,dispSlice,vol,iView)

if isempty(dispSlice)
  xLabelStr = '';yLabelStr = '';
  return
end
% clip
global gVol;
clipPercent = gVol{sysNum}.clipPercent;
if clipPercent
  dispSlice = clipImage(dispSlice,clipPercent);
end

% make into image with index values
minDispSlice = min(dispSlice(:));
maxDispSlice = max(dispSlice(:));
dispSlice = ceil(256*(dispSlice-minDispSlice)/(maxDispSlice-minDispSlice));

% if image has all the same values, display as white if the value is not 0
if isequal(minDispSlice,maxDispSlice) && ~isequal(minDispSlice,0)
  dispSlice(:) = 256;
end

% do transpose if necessary
if vol.transpose(iView)
  dispSlice = dispSlice';
  xLabelStr = vol.dispAxisLabels{vol.xDim(iView)};
  yLabelStr = vol.dispAxisLabels{vol.yDim(iView)};
  % flip axis if necessary (note that Matlab shows the x axis as - to +
  % and the y -axis in the opposite orientation, so we treat the x and y differently)
  if vol.axisDir(vol.xDim(iView)) == -1,dispSlice = fliplr(dispSlice);end
  if vol.axisDir(vol.yDim(iView)) == 1,dispSlice = flipud(dispSlice);end
else
  xLabelStr = vol.dispAxisLabels{vol.yDim(iView)};
  yLabelStr = vol.dispAxisLabels{vol.xDim(iView)};
  % flip axis if necessary (note that Matlab shows the x axis as - to +
  % and the y -axis in the opposite orientation, so we treat the x and y differently)
  if vol.axisDir(vol.xDim(iView)) == 1,dispSlice = flipud(dispSlice);end
  if vol.axisDir(vol.yDim(iView)) == -1,dispSlice = fliplr(dispSlice);end
end

%%%%%%%%%%%%%%%%%%%
%    clipImage    %
%%%%%%%%%%%%%%%%%%%
function img = clipImage(img,clipPercent)

% Choose a sensible clipping value - that is we want to remove bins
% at the low and top end for which there are less than clipPercent voxels
histThresh = length(img(:))*(clipPercent/100);
[cnt, val] = hist(img(:),1000);
% find  bin that exceeds the number of voxels expected for cutoff
numVoxels = cumsum(cnt);
clipMin = val(last(find(numVoxels<histThresh)));
if isempty(clipMin),clipMin = min(img(:));end
% find first last bin that exceeds the number of voxels expected for cutoff
numVoxels = cumsum(fliplr(cnt));
val = fliplr(val);
clipMax = val(last(find(numVoxels<histThresh)));
if isempty(clipMax),clipMax = max(img(:));end

% clip the image to these boundaries
if clipMax > clipMin
  img(img<clipMin) = clipMin;
  img(img>clipMax) = clipMax;
end

%%%%%%%%%%%%%%%%%%%%%
%    setVolCoord    %
%%%%%%%%%%%%%%%%%%%%%
function setVolCoord(sysNum,iVol,coord)

global gVol;

% check bounds
coord(coord<1) = 1;
dim = gVol{sysNum}.vols(iVol).h.dim;
outOfBounds = coord(1:length(dim)) > dim;
coord(outOfBounds) = dim(outOfBounds);

% set the current x,y,z coordinate
gVol{sysNum}.vols(iVol).coord = round(coord);

% now this sets the indexes from the volume for which the
% image will be displayed
for iView = 1:3
  for jAxis = 1:3
    if jAxis ~= gVol{sysNum}.vols(iVol).viewDim(iView)
      gVol{sysNum}.vols(iVol).viewIndexes{iView,jAxis} = 1:gVol{sysNum}.vols(iVol).h.dim(jAxis);
    else
      gVol{sysNum}.vols(iVol).viewIndexes{iView,jAxis} = gVol{sysNum}.vols(iVol).coord(jAxis);
    end
  end
end

%%%%%%%%%%%%%%%%%%%%%%%%%%
%    setTetheredCoord    %
%%%%%%%%%%%%%%%%%%%%%%%%%%
function setTetheredCoord(sysNum,iVol,iRefvol)

global gVol;

% get coord we are tethering to
coord = gVol{sysNum}.vols(iRefvol).coord;

% see if we have already updated
if isequal(gVol{sysNum}.vols(iVol).curCoord,coord)
  return
end

% look in cache for precalculate
dispSlice = mrCache('find',gVol{sysNum}.vols(iVol).c,mynum2str(coord));
if ~isempty(dispSlice)
  gVol{sysNum}.vols(iVol).dispSlice = dispSlice;
else
  % create an image
  for iView = 1:3
    % get the coordinates of the reference volume
    [x y z] = ndgrid(gVol{sysNum}.vols(iRefvol).viewIndexes{iView,1},gVol{sysNum}.vols(iRefvol).viewIndexes{iView,2},gVol{sysNum}.vols(iRefvol).viewIndexes{iView,3});
    s = size(x);
    % make into coords for multiplying
    coords = [x(:) y(:) z(:)]';
    coords(4,:) = 1;
    % convert from the reference volume coordinates to our coordinates
    coords = applyOriginXform(inv(gVol{sysNum}.vols(iVol).xform)) * coords;
    x = reshape(coords(1,:),s);
    y = reshape(coords(2,:),s);
    z = reshape(coords(3,:),s);
    % get the interpolated image (note that interp3 needs to have y
    % and x swaped to work correctly here)
    coord = gVol{sysNum}.vols(iVol).coord;
    % nDims hard coded to 5 here
    gVol{sysNum}.vols(iVol).dispSlice{iView} = squeeze(interp3(gVol{sysNum}.vols(iVol).data(:,:,:,coord(4),coord(5)),y,x,z,gVol{sysNum}.interpMethod,nan));
  end
  % save in cache
  gVol{sysNum}.vols(iVol).c = mrCache('add',gVol{sysNum}.vols(iVol).c,mynum2str(coord),gVol{sysNum}.vols(iVol).dispSlice);
end

% set the coordinate so that we update correctly
gVol{sysNum}.vols(iVol).coord = coord;

%%%%%%%%%%%%%%%%%%%%%%%%
%%   dispHeaderInfo   %%
%%%%%%%%%%%%%%%%%%%%%%%%
function dispHeaderInfo(sysNum,vol)

global gVol;

if gVol{sysNum}.verbose
  mlrImageHeaderDisp(vol.h,'verbose',gVol{sysNum}.verbose);
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    UI control functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%
%%   makeTextbox   %%
%%%%%%%%%%%%%%%%%%%%%
function h = makeTextbox(sysNum,displayString,rownum,colnum);

h = uicontrol('Style','text','String',displayString,'Position',getUIControlPos(sysNum,rownum,colnum,1),'FontSize',10,'FontName','Helvetica','HorizontalAlignment','Center','Callback',sprintf('mlrVol(3,%i)',sysNum));

%%%%%%%%%%%%%%%%%%%%%%%
%%   makePushbuton   %%
%%%%%%%%%%%%%%%%%%%%%%%
function h = makeButton(sysNum,displayString,textboxNum,rownum,colnum)

h = uicontrol('Style','pushbutton','String',displayString,'Position',getUIControlPos(sysNum,rownum,colnum,1),'FontSize',10,'FontName','Helvetica','HorizontalAlignment','Center','Callback',sprintf('mlrVol(5,%i,%i)',textboxNum,sysNum));

%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   makeTextboxIncDec   %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [h hIncDec] = makeTextboxIncDec(sysNum,displayString,textboxNum,rownum,colnum)

% make textbox
h = uicontrol('Style','edit','String',displayString,'Position',getUIControlPos(sysNum,rownum,colnum+.125,0.75),'FontSize',10,'FontName','Helvetica','HorizontalAlignment','Center','Callback',sprintf('mlrVol(3,%i,%i)',sysNum,textboxNum));

% put up incdec buttons
hIncDec(1) = uicontrol('Style','pushbutton','String','<','Position',getUIControlPos(sysNum,rownum,colnum,.1),'FontSize',10,'FontName','Helvetica','HorizontalAlignment','Center','Callback',sprintf('mlrVol(4,%i,-1,%i)',textboxNum,sysNum));
hIncDec(2) = uicontrol('Style','pushbutton','String','>','Position',getUIControlPos(sysNum,rownum,colnum+.9,.1),'FontSize',10,'FontName','Helvetica','HorizontalAlignment','Center','Callback',sprintf('mlrVol(4,%i,1,%i)',textboxNum,sysNum));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% getUIControlPos returns a location for a uicontrol
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function pos = getUIControlPos(sysNum,rownum,colnum,uisize)

global gVol;

% set this buttons width
thisButtonWidth = gVol{sysNum}.buttonWidth*uisize;

% set the position for the button
pos(1) = (gVol{sysNum}.buttonWidth+gVol{sysNum}.buttonWidthMargin)*(floor(colnum)-1)+gVol{sysNum}.buttonLeftMargin+(colnum-floor(colnum))*gVol{sysNum}.buttonWidth;
pos(2) = gVol{sysNum}.buttonBottomMargin + (gVol{sysNum}.buttonHeight+gVol{sysNum}.buttonHeightMargin)*(rownum-1);
pos(3) = thisButtonWidth;
pos(4) = gVol{sysNum}.buttonHeight;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    transformation (displaying alignment) functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%
%    applyoriginform    %
%%%%%%%%%%%%%%%%%%%%%%%%%
function xform = applyOriginXform(xform)

global gVol;

xform = inv(shiftOriginXform) * xform * shiftOriginXform;

%%%%%%%%%%%%%%%%%%%%
%    getVol2vol    %
%%%%%%%%%%%%%%%%%%%%
function vol2vol = getVol2vol(sysNum,vol1,vol2,forceQform)

global gVol;
verbose = gVol{sysNum}.verbose;
if nargin < 4,forceQform = false;end

if forceQform
  vol2vol = inv(vol2.h.qform) * vol1.h.qform;
  if verbose
    dispHeader('Aliging using qform');
    disp(sprintf('%s',mynum2str(vol2vol,'compact=0')))
    dispHeader;
  end
elseif ~isempty(vol1.h.sform) && ~isempty(vol2.h.sform)
  vol2vol = inv(vol2.h.sform) * vol1.h.sform;
  if verbose
    dispHeader('Aliging using sform');
    disp(sprintf('%s',mynum2str(vol2vol,'compact=0')))
    dispHeader;
  end
elseif ~isempty(vol1.h.qform) && ~isempty(vol2.h.qform)
  vol2vol = inv(vol2.h.qform) * vol1.h.qform;
  if verbose
    dispHeader('Aliging using qform');
    disp(sprintf('%s',mynum2str(vol2vol,'compact=0')))
    dispHeader;
  end
elseif (sum(~isnan(vol1.h.pixdim)) >= 3) && (sum(~isnan(vol2.h.pixdim)) >= 3)
  % find the shift to the center of each volume (so that the identity alignment
  % assumes that the centers of the volumes are in register)
  shiftToCenter2 = eye(4);
  shiftToCenter2(1:3,4) = -((vol2.h.dim(1:3)'/2) - 1/2);
  shiftToCenter1 = eye(4);
  shiftToCenter1(1:3,4) = -((vol1.h.dim(1:3)'/2) - 1/2);
  % get voxel size scale matrix
  voxelSize1 = diag([vol1.h.pixdim(1:3) 1]);
  voxelSize2 = diag([vol2.h.pixdim(1:3) 1]); 
  % get xform
  vol2vol = inv(voxelSize2*shiftToCenter2) * voxelSize1*shiftToCenter1;
else
  vol2vol = eye(4);
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    Auxillary functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%
%    dispHeader    %
%%%%%%%%%%%%%%%%%%%%
function retval = dispHeader(header,len,c)

% check arguments
if ~any(nargin == [0 1 2 3])
  help dispHeader
  return
end

% default header is just a full line
if nargin < 1, header = '';end

% default length
if (nargin < 2) || isempty(len),len = 60;end

% default separator character
if (nargin < 3) || isempty(c),c = '=';end

% get length of texgt
headerLen = length(header);

% if it is longer than the desired header length, then
% display two lines of separators one above and below the header
if (headerLen+2) >= len
  disp(repmat(c,1,len));
  disp(header)
  disp(repmat(c,1,len));
elseif headerLen == 0
  % if the header is empty, just display a full line
  disp(repmat(c,1,len));
else
  % otherwise put header inside separator characters
  fillerLen = ((len-(headerLen+2))/2);
  
  % display the first part
  disp(sprintf('%s %s %s',repmat(c,1,floor(fillerLen)),header,repmat(c,1,ceil(fillerLen))));
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    Functions for controls
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%
%    displayControls    %
%%%%%%%%%%%%%%%%%%%%%%%%%
function displayControls(sysNum)

global gVol;

if gVol{sysNum}.n > 1
  paramsInfo = {...
    {'toggleOverlay',0,'type=pushbutton','callback',@toggleOverlay,'buttonString','Toggle overlay','callbackArg',sysNum,'Toggle display the overlay'}...
    {'overlayAlpha',gVol{sysNum}.overlayAlpha,'incdec=[-0.2 0.2]','minmax=[0 1]','callback',@overlayAlpha,'callbackArg',sysNum,'passParams=1','Change the alpha of the overlay to make it more or less transparent'}...
    {'displayInterpolated',0,'type=checkbox','callback',@displayInterpolated,'callbackArg',sysNum,'Display image interpolated to match the primary volume'}...
    {'dispCorrelation',0,'type=pushbutton','callback',@dispCorrelation,'buttonString','Display correlation','callbackArg',sysNum,'Display correlation between aligned volume images'}...
    {'initFromHeader',0,'type=pushbutton','callback',@adjustAlignment,'buttonString','Init from header','callbackArg',{sysNum 'initFromHeader'},'passParams=1','Reinit the alignment using the qform/sform info from the headers'}};
  % if both have sforms set then offer ability to initFromHeaderUsingQform
  if ~isempty(gVol{sysNum}.vols(1).h.sform) && ~isempty(gVol{sysNum}.vols(2).h.sform)
    paramsInfo = {paramsInfo{:} {'initFromHeaderUsingQform',0,'type=pushbutton','callback',@adjustAlignment,'buttonString','Init from header using qform','callbackArg',{sysNum 'initFromHeaderUsingQform'},'passParams=1','Reinit the alignment using the original qform (rather than through the sform) info from the headers'}};
  end
  paramsInfo = {paramsInfo{:} ...
    {'setToIdentity',0,'type=pushbutton','callback',@adjustAlignment,'buttonString','Set to identity','callbackArg',{sysNum 'setToIdentity'},'passParams=1','Set the alignment to identity'}...
    {'swapXY',0,'type=pushbutton','callback',@adjustAlignment,'buttonString','Swap XY','callbackArg',{sysNum 'swapXY'},'passParams=1','Swap XY in the alignment'}...
    {'swapXZ',0,'type=pushbutton','callback',@adjustAlignment,'buttonString','Swap XZ','callbackArg',{sysNum 'swapXZ'},'passParams=1','Swap XZ in the alignment'}...
    {'swapYZ',0,'type=pushbutton','callback',@adjustAlignment,'buttonString','Swap YZ','callbackArg',{sysNum 'swapYZ'},'passParams=1','Swap YZ in the alignment'}...
    {'flipX',0,'type=pushbutton','callback',@adjustAlignment,'buttonString','Flip X','callbackArg',{sysNum 'flipX'},'passParams=1','Flip X axis in alignment'}...
    {'flipY',0,'type=pushbutton','callback',@adjustAlignment,'buttonString','Flip Y','callbackArg',{sysNum 'flipY'},'passParams=1','Flip Y axis in alignment'}...
    {'flipZ',0,'type=pushbutton','callback',@adjustAlignment,'buttonString','Flip Z','callbackArg',{sysNum 'flipZ'},'passParams=1','Flip Z axis in alignment'}...
    {'shiftX',0,'incdec=[-1 1]','callback',@adjustAlignment,'callbackArg',{sysNum 'shiftX'},'passParams=1','Shift X axis in alignment in units of mm (Note that x axis is the axis of the volume which is being interpolated - make sure to unclick displayInterpolated to see these axis)'}...
    {'shiftY',0,'incdec=[-1 1]','callback',@adjustAlignment,'callbackArg',{sysNum 'shiftY'},'passParams=1','Shift Y axis in alignment in units of mm (Note that y axis is the axis of the volume which is being interpolated - make sure to unclick displayInterpolated to see these axis)'}...
    {'shiftZ',0,'incdec=[-1 1]','callback',@adjustAlignment,'callbackArg',{sysNum 'shiftZ'},'passParams=1','Shift Z axis in alignment in units of mm (Note that z axis is the axis of the volume which is being interpolated - make sure to unclick displayInterpolated to see these axis)'}...
    {'shiftSlice',0,'incdec=[-1 1]','callback',@adjustAlignment,'callbackArg',{sysNum 'shiftSlice'},'passParams=1','Shift alignment by number of slices. For example, you can shift your xform so that the xform starts at a different slice number - this is in units of slices'}...
    {'rotateXY',0,'incdec=[-1 1]','callback',@adjustAlignment,'callbackArg',{sysNum 'rotateXY'},'passParams=1','Rotate in XY plane in units of degrees'}...
    {'rotateXZ',0,'incdec=[-1 1]','callback',@adjustAlignment,'callbackArg',{sysNum 'rotateXZ'},'passParams=1','Rotate in XZ plane in units of degrees'}...
    {'rotateYZ',0,'incdec=[-1 1]','callback',@adjustAlignment,'callbackArg',{sysNum 'rotateYZ'},'passParams=1','Rotate in YZ plane in units of degrees'}...
    {'vol2vol',gVol{sysNum}.vols(2).xform,'callback',@adjustAlignment,'callbackArg',{sysNum 'vol2vol'},'passParams=1','Directly set the alignment transform - this gets composited with the shift and rotate paramters above'}...
    {'dispHeader',0,'type=pushbutton','callback',@dispVolHeader,'buttonString','Display header','callbackArg',{sysNum [1 2]},sprintf('Display the header for %s',gVol{sysNum}.vols(2).h.filename)}...
    {'saveAlignment',0,'type=pushbutton','callback',@saveAlignment,'buttonString','Save alignment','callbackArg',sysNum,sprintf('Save the alignment to %s',gVol{sysNum}.vols(2).h.filename)}...
    {'dispAlignSteps',0,'type=pushbutton','callback',@dispAlignment,'buttonString','Display alignment steps','callbackArg',sysNum,'Displays the alignment steps used from the menu above to arrive at the current alignment. Hold down shift to see a list of all commands, rather than a summary.'}
	     };
else
  paramsInfo = {...
      {'save',0,'type=pushbutton','callback',@saveVol,'buttonString','Save volume','callbackArg',sysNum,'Save the volume'}...
      {'orient',0,'type=pushbutton','callback',@orientVol,'buttonString','Convert to LPI','callbackArg',sysNum,'Change the volume data to a canonical orientation. Note that this may not change the view in the viewer if the xform information is correct - but the axis labels may change'}...
      {'clipPercent',gVol{sysNum}.clipPercent,'minmax=[0 100]','incdec=[-0.1 0.1]','callback',@setClipPercent,'callbackArg',sysNum,'passParams=1','Change the percent of voxels with low and high values that will be clipped in the display. This helps to set the image contrast so that everything is visible even if there are a few stray voxels with large or small values. Note that the mouse over will still correctly display the unclipped value'}...
      {'swapXY',0,'type=pushbutton','callback',@adjustVol,'buttonString','Swap XY','callbackArg',{sysNum 'swapXY'},'passParams=1','Swap XY of volume. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'swapXZ',0,'type=pushbutton','callback',@adjustVol,'buttonString','Swap XZ','callbackArg',{sysNum 'swapXZ'},'passParams=1','Swap XZ of volume. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'swapYZ',0,'type=pushbutton','callback',@adjustVol,'buttonString','Swap YZ','callbackArg',{sysNum 'swapYZ'},'passParams=1','Swap YZ of volume. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'flipX',0,'type=pushbutton','callback',@adjustVol,'buttonString','Flip X','callbackArg',{sysNum 'flipX'},'passParams=1','Flip X axis of volume. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'flipY',0,'type=pushbutton','callback',@adjustVol,'buttonString','Flip Y','callbackArg',{sysNum 'flipY'},'passParams=1','Flip Y axis of volume. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'flipZ',0,'type=pushbutton','callback',@adjustVol,'buttonString','Flip Z','callbackArg',{sysNum 'flipZ'},'passParams=1','Flip Z axis of volume. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'shiftX',0,'incdec=[-1 1]','callback',@adjustVol,'callbackArg',{sysNum 'shiftX'},'passParams=1','Shift X axis of volume in units of voxels. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'shiftY',0,'incdec=[-1 1]','callback',@adjustVol,'callbackArg',{sysNum 'shiftX'},'passParams=1','Shift Y axis of volume in units of voxels. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'shiftZ',0,'incdec=[-1 1]','callback',@adjustVol,'callbackArg',{sysNum 'shiftX'},'passParams=1','Shift Z axis of volume in units of voxels. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'rotateXY',0,'incdec=[-1 1]','callback',@adjustVol,'callbackArg',{sysNum 'rotateXY'},'passParams=1','Rotate in XY plane in units of degrees. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'rotateXZ',0,'incdec=[-1 1]','callback',@adjustVol,'callbackArg',{sysNum 'rotateXZ'},'passParams=1','Rotate in XZ plane in units of degrees. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'rotateYZ',0,'incdec=[-1 1]','callback',@adjustVol,'callbackArg',{sysNum 'rotateYZ'},'passParams=1','Rotate in YZ plane in units of degrees. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'xMin',1,'incdec=[-1 1]','minmax',[1 gVol{sysNum}.vols(1).h.dim(1)],'callback',@adjustVol,'callbackArg',{sysNum 'xMin'},'passParams=1','round=1','Crop the image in the x dimension. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'xMax',inf,'incdec=[-1 1]','minmax',[1 gVol{sysNum}.vols(1).h.dim(1)],'callback',@adjustVol,'callbackArg',{sysNum 'xMax'},'passParams=1','round=1','Crop the image in the x dimension. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'yMin',1,'incdec=[-1 1]','minmax',[1 gVol{sysNum}.vols(1).h.dim(2)],'callback',@adjustVol,'callbackArg',{sysNum 'yMin'},'passParams=1','round=1','Crop the image in the y dimension. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'yMax',inf,'incdec=[-1 1]','minmax',[1 gVol{sysNum}.vols(1).h.dim(2)],'callback',@adjustVol,'callbackArg',{sysNum 'yMax'},'passParams=1','round=1','Crop the image in the y dimension. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'zMin',1,'incdec=[-1 1]','minmax',[1 gVol{sysNum}.vols(1).h.dim(3)],'callback',@adjustVol,'callbackArg',{sysNum 'zMin'},'passParams=1','round=1','Crop the image in the z dimension. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'zMax',inf,'incdec=[-1 1]','minmax',[1 gVol{sysNum}.vols(1).h.dim(3)],'callback',@adjustVol,'callbackArg',{sysNum 'zMax'},'passParams=1','round=1','Crop the image in the z dimension. Hold down shift while clicking this to only apply xform to image and not to header.'}...
      {'dispVolHeader',0,'type=pushbutton','callback',@dispVolHeader,'buttonString','Display header','callbackArg',{sysNum 1},'Display the header for the volume'}...
      {'editVolHeader',0,'type=pushbutton','callback',@editVolHeader,'buttonString','Edit header','callbackArg',{sysNum 1},'Edit the header for the volume'}...
	       };
end

% add ability to change display of alternate coordinates
altXforms = gVol{sysNum}.vols(1).altXforms;
if altXforms.n 
  paramsInfo{end+1} = {'altCoord',putOnTopOfList(altXforms.names{altXforms.currentXform},altXforms.names),'callback',@changeAltCoord,'callbackArg',sysNum,'passParams=1'};
end
if isfield(gVol{sysNum}.vols(1),'complexData')
  paramsInfo{end+1} = {'dispComplex',putOnTopOfList(gVol{sysNum}.dispComplex,{'magnitude','phase','fft2 magnitude','fft2 phase','fft3 magnitude','fft3 phase'}),'callback',@dispComplex,'callbackArg',sysNum,'passParams=1','Change how complex data is displayed'};
end
%mrParamsDialog(paramsInfo,'mlrVol Controls',[],@controlsCallback);
gVol{sysNum}.controlsUp = true;
mrParamsDialog(paramsInfo,'mlrVol Controls','callbackArg',sysNum,'okCallback',@controlsCallback);

%%%%%%%%%%%%%%%%%%%%%%%%
%    setClipPercent    %
%%%%%%%%%%%%%%%%%%%%%%%%
function retval = setClipPercent(sysNum,params)

global gVol;

% set the return value
retval = params.clipPercent;

% set the clipPercent
gVol{sysNum}.clipPercent = params.clipPercent;

% redisplay
gVol{sysNum}.vols.curCoord(:) = nan;
refreshDisplay(sysNum);

%%%%%%%%%%%%%%%%%%%%%%%
%    editVolHeader    %
%%%%%%%%%%%%%%%%%%%%%%%
function retval = editVolHeader(args)

% return argument for mrParams
retval = 1;

global gVol;
sysNum = args{1};
volNum = args{2};

% get the header
vol = gVol{sysNum}.vols(volNum);
h = vol.h;

% close controls
if isfield(gVol{sysNum},'controlsUp') && gVol{sysNum}.controlsUp
  mrParamsClose;
end

% edit the header
gVol{sysNum}.vols(volNum).h = mlrImageHeaderEdit(h);

% update the axis info
gVol{sysNum}.vols(1) = updateVolAxisInfo(sysNum,gVol{sysNum}.vols(1),gVol{sysNum}.vols(1).h);
setVolCoord(sysNum,1,gVol{sysNum}.vols(1).coord);

% redisplay
gVol{sysNum}.vols.curCoord(:) = nan;
refreshDisplay(sysNum);

%%%%%%%%%%%%%%%%%%%%%%%
%    dispVolHeader    %
%%%%%%%%%%%%%%%%%%%%%%%
function retval = dispVolHeader(args)

% return argument for mrParams
retval = 1;

global gVol;
sysNum = args{1};
volNums = args{2};

for iVol = 1:length(volNums)
  vol = gVol{sysNum}.vols(volNums(iVol));
  % for aligned volumes, than get the alignment sform so we can display that
  if volNums(iVol) > 1
    vol.h.sform = gVol{sysNum}.vols(1).h.qform * vol.xform; 
  end

  mlrImageHeaderDisp(vol.h);
end

%%%%%%%%%%%%%%%%%%%
%    adjustVol    %
%%%%%%%%%%%%%%%%%%%
function retval = adjustVol(args,params)

% return argument for mrParams
retval = 1;

global gVol;
sysNum = args{1};

% get command name and value
commandName = args{2};
commandValue = params.(commandName);

% see if shift key is down, in whcih case we don't apply to header
if any(strcmp(get(gcf,'CurrentModifier'),'shift'))
  disp(sprintf('(mlrVol:adjustVol) Only applying %s to image data not header',commandName));
  applyToHeader = 0;
else
  if ~gVol{sysNum}.imageOrientation
    oneTimeWarning('mlrVolAdjustDims','(mlrVol:adjustDims) Note that when you apply a transformation, the same transformation gets applied to the header xform and mlrVol will adjust the display to compensate (so for example if you swap XY it will swap the labels of the axis, but not necessarily what is being displayed). If instead you want to swap the data but NOT the header xform, then hold down the shift key as you make the adjustments');
  end
  applyToHeader = 1;
end

% do the command
[gVol{sysNum}.vols(1).data gVol{sysNum}.vols(1).h xform] = mlrImageXform(gVol{sysNum}.vols(1).data,gVol{sysNum}.vols(1).h,commandName,commandValue,'applyToHeader',applyToHeader);

% update the axis info
gVol{sysNum}.vols(1) = updateVolAxisInfo(sysNum,gVol{sysNum}.vols(1),gVol{sysNum}.vols(1).h);

% get the new coord after xformation
coord = xform*[gVol{sysNum}.vols(1).coord(1:3)' ; 1];
gVol{sysNum}.vols(1).coord(1:3) = coord(1:3);
setVolCoord(sysNum,1,gVol{sysNum}.vols(1).coord);

% redisplay
gVol{sysNum}.vols.curCoord(:) = nan;
refreshDisplay(sysNum);

% clear the parameter
if any(strcmp(commandName,{'xMax','yMax','zMax'}))
  params.(commandName) = inf;
else
  params.(commandName) = 0;
end
  
mrParamsSet(params);

%%%%%%%%%%%%%%%%%%%
%    orientVol    %
%%%%%%%%%%%%%%%%%%%
function retval = orientVol(sysNum)

% return argument for mrParams
retval = [];

global gVol;

% get what orientation the image is
axisLabels = mlrImageGetAxisLabels(gVol{sysNum}.vols(1).h.qform);
if isempty(axisLabels),return,end

% put up a dialog box so user can select the orientation to save to
paramsInfo = {...
    {'currentOrientation',axisLabels.orient,'editable=0','This is the orientation that the volume is in'},...
    {'desiredOrientation','LPI','Set this to whatever orientation you want as specified by the three letter string which can be composed of L for left or R for right and A for anterior or P for Posterior and S for superior and I for inferior.'}...
	     };
params = mrParamsDialog(paramsInfo,'Choose desired orientation');
if isempty(params),return,end

% orient the voliume in LPI
[gVol{sysNum}.vols(1).data gVol{sysNum}.vols(1).h] = mlrImageOrient(params.desiredOrientation,gVol{sysNum}.vols(1).data,gVol{sysNum}.vols(1).h);

% update the axis info
gVol{sysNum}.vols(1) = updateVolAxisInfo(sysNum,gVol{sysNum}.vols(1),gVol{sysNum}.vols(1).h);
setVolCoord(sysNum,1,gVol{sysNum}.vols(1).coord);

% redisplay
gVol{sysNum}.vols.curCoord(:) = nan;
refreshDisplay(sysNum);

%%%%%%%%%%%%%%%%%
%    saveVol    %
%%%%%%%%%%%%%%%%%
function retval = saveVol(sysNum)

% return argument for mrParams
retval = [];

global gVol;
vol = gVol{sysNum}.vols(1);

% get directory to start save box in
[filename pathname ] = uiputfile({'*.hdr;*.img;*.nii','Nifti format';'*.sdt;*.spr;*.edt*.epr','BSI stimulate format'},'Save volume',vol.h.filename);
if isequal(filename,0),return,end

mlrImageSave(fullfile(pathname,filename),vol.data,vol.h);

%%%%%%%%%%%%%%%%%%%%%%%
%    dispAlignment    %
%%%%%%%%%%%%%%%%%%%%%%%
function retval = dispAlignment(sysNum)

% return argument for mrParams
retval = [];

global gVol;

% check to see if anything has been done
if isempty(gVol{sysNum}.alignmentSteps)
  disp(sprintf('(mlrVol:dispAlignment) No manual alignment steps have been applied'));
  return
end

if any(strcmp(get(gcf,'CurrentModifier'),'shift'))
  dispAllSteps = true;
else
  dispAllSteps = false;
end

startCommand = 'initFromHeader';
startCommandNum = 0;
if dispAllSteps,dispHeader('Displaying all alignment steps');end
for iStep = 1:length(gVol{sysNum}.alignmentSteps)
  commandName = gVol{sysNum}.alignmentSteps(iStep).name;
  commandVal = gVol{sysNum}.alignmentSteps(iStep).val;
  % get how to display the command
  dispCommand = dispAlignmentCommand(commandName,commandVal);
  if any(strcmp(commandName,{'initFromHeader','setToIdentity'}))
    % set this as a starting point of alignment for showing the compact version below
    startCommand = commandName;
    startCommandNum = iStep;
    % display what was done
    if dispAllSteps,dispHeader(startCommand);end
  elseif strcmp(commandName,'vol2vol')
    % set this as a starting point of alignment for showing the compact version below
    startCommand = commandName;
    startCommandNum = iStep;
    if dispAllSteps
      dispHeader('Set vol2vol');
      disp(sprintf('%i: %s',iStep,dispCommand));
    end
  else
    if dispAllSteps,disp(sprintf('%i: %s',iStep,dispCommand));end
  end
end
if dispAllSteps,return,end

% display summary of alignment steps 
dispHeader('Displaying summary of alignment steps');
disp(sprintf('%s',startCommand));
lastCommand = '';lastCommandVal = '';
for iStep = (startCommandNum+1):length(gVol{sysNum}.alignmentSteps)
  commandName = gVol{sysNum}.alignmentSteps(iStep).name;
  commandVal = gVol{sysNum}.alignmentSteps(iStep).val;
  % see if we need to display the command val or not
  if any(strcmp(commandName,{'swapXY','swapXZ','swapYZ','flipX','flipY','flipZ'}))
    % if the last command was the same as this command, then nothing
    % in effect was done, so forget that anything happenedn
    if strcmp(lastCommand,commandName)
      lastCommand = ''; 
    else
      % display the last one
      disp(dispAlignmentCommand(lastCommand,lastCommandVal));
      lastCommand = commandName;
    end
  elseif any(strcmp(commandName,{'shiftX','shiftY','shiftZ'}))
    % if the last command was not a shift then beginning storage of the shift
    if ~strcmp(lastCommand,'shift')
      % display the last command
      disp(dispAlignmentCommand(lastCommand,lastCommandVal));
      lastCommandVal = [0 0 0];
    end
    % set the shift
    if strcmp(commandName,'shiftX')
      lastCommandVal(1) = lastCommandVal(1) + commandVal;
    elseif strcmp(commandName,'shiftY')
      lastCommandVal(2) = lastCommandVal(2) + commandVal;
    elseif strcmp(commandName,'shiftZ')
      lastCommandVal(3) = lastCommandVal(3) + commandVal;
    end
    lastCommand = 'shift';
  elseif any(strcmp(commandName,{'shiftSlice'}))
    % if the last command was not a shiftSlice
    if ~strcmp(lastCommand,'shiftSlice')
      % display the last command
      disp(dispAlignmentCommand(lastCommand,lastCommandVal));
      lastCommandVal = 0;
    end
    lastCommandVal = lastCommandVal+commandVal;
    lastCommand = 'shiftSlice';
  elseif any(strcmp(commandName,{'rotateXY','rotateXZ','rotateYZ'}))
    % if the last command was the same rotation or not
    if strcmp(lastCommand,commandName)
      % then add to the rotation angle
      lastCommandVal = lastCommandVal + commandVal;
    else
      % otherwise display last command
      disp(dispAlignmentCommand(lastCommand,lastCommandVal));
      lastCommandVal = commandVal;
    end
    lastCommand = commandName;
  end
end

% display the last one
disp(dispAlignmentCommand(lastCommand,lastCommandVal));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    dispAlignmentCommand    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function dispCommand = dispAlignmentCommand(commandName,commandVal)

dispCommand = '';
if isempty(commandName),return,end

% see if we need to display the command val or not
if any(strcmp(commandName,{'swapXY','swapXZ','swapYZ','flipX','flipY','flipZ'}))
  % display what was done
  dispCommand = sprintf('%s',commandName);
elseif any(strcmp(commandName,{'initFromHeader','setToIdentity'}))
  % display what was done
  dispCommand = commandName;
elseif strcmp(commandName,'vol2vol')
  dispCommand = sprintf('%s\n%s',commandName,mlrnum2str(commandVal,'compact=0'));
else
  % display what was done
  dispCommand = sprintf('%s %s',commandName,mlrnum2str(commandVal,'compact=1'));
end


%%%%%%%%%%%%%%%%%%%%%%%
%    saveAlignment    %
%%%%%%%%%%%%%%%%%%%%%%%
function retval = saveAlignment(sysNum)

% return argument for mrParams
retval = [];

global gVol;
vol = gVol{sysNum}.vols(2);

% get directory to start save box in
[filename pathname ] = uiputfile({'*.hdr;*.img;*.nii','Nifti format';'*.sdt;*.spr;*.edt*.epr','BSI stimulate format'},'Save volume',vol.h.filename);
if isequal(filename,0),return,end

% compute the sform, remember to composite the system xform (shifts and rotates)
% then the base volumes qform which takes us from the base volumes coordinates back to 
% the magnet coordiantes
qform = gVol{sysNum}.vols(1).h.qform;
if isempty(qform)
  disp(sprintf('(mlrVol:saveAlignment) !!! %s does not have qform set !!!',gVol{sysNum}.vols(1).h.filename));
  if ~any(isnan(gVol{sysNum}.vols(1).h.pixdim(1:3)))
    disp(sprintf('(mlrVol:saveAlignment) Using pixdim to create qform',gVol{sysNum}.vols(1).h.filename));
    qform = diag([gVol{sysNum}.vols(1).h.pixdim(1:3) 1]);
  else
    disp(sprintf('(mlrVol:saveAlignment) Using identity for qform',gVol{sysNum}.vols(1).h.filename));
    qform = eye(4);
  end
end

sform = qform * vol.xform;

% set the qform as well, if the sform
paramsInfo = {...
    {'filename',filename,'editable=0'}...
    {'saveAsQform',isempty(vol.h.qform),'type=checkbox','Save alignment as qform - usually you do not want to do this since the qform should hold the information about the alignment set by the magnet. But in cases where you don''t have this information set, you may want to set the qform'}...
    {'saveAsSform',1,'type=checkbox','Save alignment as qform - usually you do not want to do this since the qform should hold the information about the alignment set by the magnet. But in cases where you don''t have this information set, you may want to set the qform'}...
    {'sform',sform,'The sform that will be save'}...
	     };
params = mrParamsDialog(paramsInfo,'Save alignment');
if isempty(params),return,end

if params.saveAsQform
  vol.h.qform = params.sform;
end
if params.saveAsSform
  vol.h.sform = params.sform;
end
  
mlrImageSave(fullfile(pathname,filename),vol.data,vol.h);

%%%%%%%%%%%%%%%%%%%%%%%%
%    changeAltCoord    %
%%%%%%%%%%%%%%%%%%%%%%%%
function retval = changeAltCoord(sysNum,params)

global gVol;
altXforms = gVol{sysNum}.vols(1).altXforms;

% find the current matching number and set it
gVol{sysNum}.vols(1).altXforms.currentXform = first(find(strcmp(params.altCoord,altXforms.names)));
shortName = altXforms.shortNames{gVol{sysNum}.vols(1).altXforms.currentXform};

% set the short names
set(gVol{sysNum}.hExtraCoordTitle(1),'String',sprintf('%s X',shortName));
set(gVol{sysNum}.hExtraCoordTitle(2),'String',sprintf('%s Y',shortName));
set(gVol{sysNum}.hExtraCoordTitle(3),'String',sprintf('%s Z',shortName));
updateExtraCoords(sysNum);

retval = [];

%%%%%%%%%%%%%%%%%%%%%%%%%%
%    controlsCallback    %
%%%%%%%%%%%%%%%%%%%%%%%%%%
function controlsCallback(sysNum)

global gVol;
gVol{sysNum}.controlsUp = false;

%%%%%%%%%%%%%%%%%%%%%
%    dispComplex    %
%%%%%%%%%%%%%%%%%%%%%
function retval = dispComplex(sysNum,params)

global gVol;

% go through all volumes
for iVol = gVol{sysNum}.n
  % if it is complex data then reset its data value
  % to display chosen field
  if isfield(gVol{sysNum}.vols(iVol),'complexData');
    switch (params.dispComplex)
     case {'magnitude'}
      gVol{sysNum}.vols(iVol).data = abs(gVol{sysNum}.vols(iVol).complexData);
     case {'phase'}
      gVol{sysNum}.vols(iVol).data = angle(gVol{sysNum}.vols(iVol).complexData);
     case {'fft2 magnitude','fft2 phase'}
      % nDims hard coded to 5 here
      mlrDispPercent(-inf,'(mlrVol) Transforming data');
      nSlice = size(gVol{sysNum}.vols(iVol).data,3);
      nVolume = size(gVol{sysNum}.vols(iVol).data,4);
      nReceiver = size(gVol{sysNum}.vols(iVol).data,5);
      for iSlice = 1:nSlice
	for iVolume = 1:nVolume
	  for iReceiver = 1:nReceiver
	    % take fft
	    fftSlice = fftshift(fft2(gVol{sysNum}.vols(iVol).complexData(:,:,iSlice,iVolume,iReceiver)));
	    % get phase or magnitude
	    if strcmp(params.dispComplex,'fft2 phase')
	      gVol{sysNum}.vols(iVol).data(:,:,iSlice,iVolume,iReceiver) = angle(fftSlice);
	    else
	      gVol{sysNum}.vols(iVol).data(:,:,iSlice,iVolume,iReceiver) = abs(fftSlice);
	    end
	    % percent correct
	    mlrDispPercent(calcPercentDone(iSlice,nSlice,iVolume,nVolume,iReceiver,nReceiver));
	  end
	end
      end
      mlrDispPercent(inf);
     case {'fft3 magnitude','fft3 phase'}
      % nDims hard coded to 5 here
      mlrDispPercent(-inf,'(mlrVol) Transforming data');
      nVolume = size(gVol{sysNum}.vols(iVol).data,4);
      nReceiver = size(gVol{sysNum}.vols(iVol).data,5);
      for iVolume = 1:nVolume
	for iReceiver = 1:nReceiver
	  % take fft
	  fftVolume = fftshift(fftn(squeeze(gVol{sysNum}.vols(iVol).complexData(:,:,:,iVolume,iReceiver))));
	  % and get phase or magnitude
	  if strcmp(params.dispComplex,'fft3 phase')
	    gVol{sysNum}.vols(iVol).data(:,:,:,iVolume,iReceiver) = angle(fftVolume);
	  else
	    gVol{sysNum}.vols(iVol).data(:,:,:,iVolume,iReceiver) = abs(fftVolume);
	  end
	  % percent done
	  mlrDispPercent(calcPercentDone(iVolume,nVolume,iReceiver,nReceiver));
	end
      end
      mlrDispPercent(inf);
    end      
    % clear cache
    gVol{sysNum}.vols(iVol).c = mrCache('init',2*max(gVol{sysNum}.vols(iVol).h.dim(1:3)));
    % and set to redisplay
    gVol{sysNum}.vols(iVol).curCoord(1:3) = nan;
  end
end

% set what value we are looking at
gVol{sysNum}.dispComplex = params.dispComplex;

% redisplay
refreshDisplay(sysNum);

%%%%%%%%%%%%%%%%%%%%%%%%%
%    adjustAlignment    %
%%%%%%%%%%%%%%%%%%%%%%%%%
function retval = adjustAlignment(args,params)

% some variables
global gVol;
retval = [];
sysNum = args{1};
command = args{2};
replaceXform = false;
changeXform = false;
verbose = gVol{sysNum}.verbose;
xformLeft = eye(4);
xformRight = eye(4);


gVol{sysNum}.alignmentSteps(end+1).name = args{2};
gVol{sysNum}.alignmentSteps(end).val = params.(args{2});

% get the necessary xform
switch args{2}
 case {'swapXY'}
  xformLeft = [0 1 0 0;1 0 0 0;0 0 1 0;0 0 0 1];
  changeXform = true;
 case {'swapXZ'}
  xformLeft = [0 0 1 0;0 1 0 0;1 0 0 0;0 0 0 1];
  changeXform = true;
 case {'swapYZ'}
  xformLeft = [1 0 0 0;0 0 1 0;0 1 0 0;0 0 0 1];
  changeXform = true;
 case {'flipX'}
  % set the xform - the nan will get set to the image size below
  xformLeft = [-1 0 0 nan;0 1 0 0;0 0 1 0; 0 0 0 1];
  changeXform = true;
 case {'flipY'}
  xformLeft = [1 0 0 0;0 -1 0 nan;0 0 1 0; 0 0 0 1];
  changeXform = true;
 case {'flipZ'}
  xformLeft = [1 0 0 0;0 1 0 0;0 0 -1 nan; 0 0 0 1];
  changeXform = true;
 case {'shiftSlice'}
  xformRight = [1 0 0 0;0 1 0 0;0 0 1 params.shiftSlice; 0 0 0 1];
  params.shiftSlice = 0;
  mrParamsSet(params);
  changeXform = true;
 case {'shiftX','shiftY','shiftZ','rotateXY','rotateXZ','rotateYZ'}
  % make rotation matrix, but need to rotate around center coordinates
  % little tricky here - the rotation has to be done respecting the voxel size
  voxelSize = diag([gVol{sysNum}.vols(2).h.pixdim(1:3) 1]);
  dim = gVol{sysNum}.vols(2).h.dim;
  shiftToCenterOfVol = makeRotMatrix3D(0,0,0,-[(dim(1)-1)/2 (dim(2)-1)/2 (dim(3)-1)/2]);
  xformRight = inv(shiftToCenterOfVol)*inv(voxelSize)*makeRotMatrix3D(-params.rotateXZ,-params.rotateYZ,-params.rotateXY,[params.shiftX params.shiftY params.shiftZ],1)*voxelSize*shiftToCenterOfVol;
  % reset coordinates back to zero in dialog box
  params.shiftX = 0;params.shiftY = 0;params.shiftZ = 0;
  params.rotateXY = 0;params.rotateXZ = 0;params.rotateYZ = 0;
  mrParamsSet(params);
  % set to change xform
  changeXform = true;
 case {'initFromHeader'}
  xform = getVol2vol(sysNum,gVol{sysNum}.vols(2),gVol{sysNum}.vols(1));
  replaceXform = true;
 case {'initFromHeaderUsingQform'}
  xform = getVol2vol(sysNum,gVol{sysNum}.vols(2),gVol{sysNum}.vols(1),true);
  replaceXform = true;
 case {'vol2vol'}
  xform = params.vol2vol;
  replaceXform = true;
 case {'setToIdentity'}
  if (sum(~isnan(gVol{sysNum}.vols(1).h.pixdim)) >= 3) && (sum(~isnan(gVol{sysNum}.vols(2).h.pixdim)) >= 3)
    % find the shift to the center of each volume (so that the identity alignment
    % assumes that the centers of the volumes are in register)
    shiftToCenter2 = eye(4);
    shiftToCenter2(1:3,4) = -((gVol{sysNum}.vols(2).h.dim(1:3)'/2) - 1/2);
    shiftToCenter1 = eye(4);
    shiftToCenter1(1:3,4) = -((gVol{sysNum}.vols(1).h.dim(1:3)'/2) - 1/2);
    % get voxel size scale matrix
    voxelSize1 = diag([gVol{sysNum}.vols(1).h.pixdim(1:3) 1]);
    voxelSize2 = diag([gVol{sysNum}.vols(2).h.pixdim(1:3) 1]); 
    % get scale factor
    xform = inv(voxelSize1*shiftToCenter1) * voxelSize2*shiftToCenter2;
  else
    xform = eye(4);
  end
  replaceXform = true;
end

% set the transform
for iVol = 2:gVol{sysNum}.n
  if verbose,dispHeader;end
  if gVol{sysNum}.vols(iVol).tethered
    if changeXform
      % see if there is a nan that needs to be replaced
      [row col] = find(isnan(xformLeft));
      if ~isempty(row)
	% replace from the appropriate coordinate
	val = gVol{sysNum}.vols(1).h.dim(row);
	xformLeft(row,col) = val;
      end
      % now set the xform
      gVol{sysNum}.vols(iVol).xform = xformLeft*gVol{sysNum}.vols(iVol).xform*xformRight;
    elseif replaceXform
      gVol{sysNum}.vols(iVol).xform = xform;
    end
    % display what we are doing
    if verbose
      disp(sprintf('(mlrVol) xform\n%s',mynum2str(gVol{sysNum}.vols(iVol).xform,'compact=0','sigfigs=-1')));
    end
    % clear cache
    gVol{sysNum}.vols(iVol).c = mrCache('init',2*max(gVol{sysNum}.vols(iVol).h.dim(1:3)));
    % update the dialog box
    updateParams.vol2vol = gVol{sysNum}.vols(iVol).xform;
    mrParamsSet(updateParams);
  end
  % set all images to redisplay
  gVol{sysNum}.vols(iVol).curCoord(1:3) = nan;
end

% set the altXform for displaying coordinates of the transformed volume
altXforms = gVol{sysNum}.vols(1).altXforms;
% get the aligned volume alternate xform
altXformNum = find(strcmp('Aligned volume',altXforms.names));
if ~isempty(altXformNum)
  gVol{sysNum}.vols(1).altXforms.xforms{altXformNum} = applyOriginXform(inv(gVol{sysNum}.vols(iVol).xform));
end

% redisplay
gVol{sysNum}.vols(1).curCoord(:) = nan;
refreshDisplay(sysNum);

%%%%%%%%%%%%%%%%%%%%%%
%    overlayAlpha    %
%%%%%%%%%%%%%%%%%%%%%%
function retval = overlayAlpha(sysNum,params)

global gVol;
gVol{sysNum}.overlayAlpha = params.overlayAlpha;

% go through volumes
for iVol = 1:gVol{sysNum}.n
  % for each tethered
  if gVol{sysNum}.vols(iVol).tethered
    % go through each view and toggle alpha
    for iView = 1:3
      alphaData = get(gVol{sysNum}.vols(iVol).overlay(iView),'AlphaData');
      mask = gVol{sysNum}.vols(iVol).overlayMask{iView};
      alphaData(mask) = gVol{sysNum}.overlayAlpha;
      set(gVol{sysNum}.vols(iVol).overlay(iView),'AlphaData',alphaData);
    end
  end
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    dispCorrelation    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function retval = dispCorrelation(sysNum)

f = gcf;

retval = [];
global gVol;

% get the two volumes
vol1 = gVol{sysNum}.vols(1);
vol2 = gVol{sysNum}.vols(2);

% open figure
if ~isfield(gVol{sysNum},'dispCorrelationFig') || isempty(gVol{sysNum}.dispCorrelationFig)
  gVol{sysNum}.dispCorrelationFig = figure;
else
  figure(gVol{sysNum}.dispCorrelationFig);
end
clf;

titleStr = '';
for iView = 1:3
  % grab the data grom the first volume
  % nDims hard coded to 5 here
  dispSlice1 = squeeze(vol1.data(vol1.viewIndexes{iView,1},vol1.viewIndexes{iView,2},vol1.viewIndexes{iView,3},vol1.coord(4),vol1.coord(5)));

  % and get the dispSlice from the tethered volume
  dispSlice2 = vol2.dispSlice{iView};

  % select only non-nan values
  nonnan = find(~isnan(dispSlice1(:)) & ~isnan(dispSlice2(:)));
  dispSlice1 = dispSlice1(nonnan);
  dispSlice2 = dispSlice2(nonnan);
  
  % compute stats
  slope = pinv(dispSlice1(:))*dispSlice2(:);
  r2 = regstats(dispSlice1(:),dispSlice2(:),'linear','rsquare');
  r2 = r2.rsquare;
  titleStr = sprintf('%s m=%0.2f r^2:%0.3f',titleStr,slope,r2);
  
  % display
  plot(dispSlice1(:),dispSlice2(:),'.','Color',getSmoothColor(iView,3));
  hold on;
end

% display the labels
title(titleStr);
xlabel(sprintf('%s voxel values',vol1.h.filename));
ylabel(sprintf('%s voxel values',vol2.h.filename));

% set the axis equal
%[xmin xmax] = xaxis;
%[ymin ymax] = yaxis;
%axis([min(xmin,ymin) max(xmax,ymax) min(xmin,ymin) max(xmax,ymax)]);

% put up diagonal
dline('k',1);

% switch back current fig
figure(f);

%%%%%%%%%%%%%%%%%%%%%%%
%    toggleOverlay    %
%%%%%%%%%%%%%%%%%%%%%%%
function retval = toggleOverlay(sysNum)

retval = [];
global gVol;

% go through volumes
for iVol = 1:gVol{sysNum}.n
  % for each tethered
  if gVol{sysNum}.vols(iVol).tethered
    % go through each view and toggle alpha
    for iView = 1:3
      alphaData = get(gVol{sysNum}.vols(iVol).overlay(iView),'AlphaData');
      mask = gVol{sysNum}.vols(iVol).overlayMask{iView};
      if alphaData(first(find(mask)))==0
	gVol{sysNum}.overlayToggleState = 1;
	alphaData(mask) = gVol{sysNum}.overlayAlpha;
	set(gVol{sysNum}.vols(iVol).overlay(iView),'AlphaData',alphaData);
      else
	alphaData(mask) = 0;
	gVol{sysNum}.overlayToggleState = 0;
	set(gVol{sysNum}.vols(iVol).overlay(iView),'AlphaData',alphaData);
      end	  
    end
  end
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   displayInterpolated   %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function displayInterpolated(sysNum,params)

global gVol;

% set the displayInterpolated state
gVol{sysNum}.displayInterpolated = params.displayInterpolated;

% set volumes to redisplay
for iVol = 1:gVol{sysNum}.n
  gVol{sysNum}.vols(iVol).curCoord(1:3) = nan;
end
gVol{sysNum}.vols(2).coord(1:3) = nan;

% and redisplay
refreshDisplay(sysNum);


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    Init functions (initSystem and loadVolume)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%
%    initSystem    %
%%%%%%%%%%%%%%%%%%%%
function [sysNum imageArgs] = initSystem(args)

% default return arguments
sysNum = [];imageArgs = [];

% split into image and arguments
[imageArgs otherArgs] = mlrImageParseArgs(args);

% check to see if there are any valid images
validImages = false;
for i = 1:length(imageArgs)
  if mlrImageIsImage(imageArgs{i})
    validImages = true;
  end
end
if ~validImages,return,end
  
%init global
global gVol;
if isempty(gVol)
  sysNum = 1;
else
  sysNum = length(gVol)+1;
end

% number of loaded volumes
gVol{sysNum}.n = 0;

% parse args here when we have settings
imageOrientation = [];verbose = [];toggleOverlay = [];
getArgs(otherArgs,{'imageOrientation=0','verbose=1','toggleOverlay=1','showControls=[]'});
gVol{sysNum}.imageOrientation = imageOrientation;
gVol{sysNum}.verbose = verbose;

% defaults for button sizes
gVol{sysNum}.buttonWidth = 100;
gVol{sysNum}.buttonWidthMargin = 20;
gVol{sysNum}.buttonHeightMargin = 2;
gVol{sysNum}.buttonHeight = 25;
gVol{sysNum}.buttonLeftMargin = 10;
gVol{sysNum}.buttonBottomMargin = 10;

% controls are not up
gVol{sysNum}.controlsUp = false;

% get location of figure
figloc = mrGetFigLoc('mlrVol');

% open the fig
gVol{sysNum}.fig(1) = figure;
if ~isempty(figloc)
  set(gVol{sysNum}.fig(1),'Position',figloc);
end
gVol{sysNum}.fig(2) = gVol{sysNum}.fig(1);
gVol{sysNum}.fig(3) = gVol{sysNum}.fig(1);
clf;drawnow

% set the mouse functions
set(gVol{sysNum}.fig(1),'WindowButtonDownFcn',sprintf('mlrVol(1,%i)',sysNum));
set(gVol{sysNum}.fig(1),'WindowButtonMotionFcn',sprintf('mlrVol(2,%i)',sysNum));
set(gVol{sysNum}.fig(1),'CloseRequestFcn',sprintf('mlrVol(6,%i)',sysNum));

% set up the axis
gVol{sysNum}.a(1) = subplot(1,3,1);cla;axis off;
gVol{sysNum}.a(2) = subplot(1,3,2);cla;axis off;
gVol{sysNum}.a(3) = subplot(1,3,3);cla;axis off;
gVol{sysNum}.subplotRows = [1 1 1];
gVol{sysNum}.subplotCols = [3 3 3];

% update display
drawnow

% no animation is running
gVol{sysNum}.animating = false;

% get interp method
gVol{sysNum}.interpMethod = mrGetPref('interpMethod');

% alpha for overlay
gVol{sysNum}.overlayAlpha = mrGetPref('mlrVolOverlayAlpha');;

% set display controls
if isempty(showControls)
  gVol{sysNum}.displayControls = mrGetPref('mlrVolDisplayControls');
else
  gVol{sysNum}.displayControls = showControls;
  % update display
  drawnow
end  

% overlay toggle state starts as on
gVol{sysNum}.overlayToggleState = toggleOverlay;

% display the tethered volume interpolated to
% match the primary volume display
gVol{sysNum}.displayInterpolated = false;

% set the clipping value (i.e. the lower and higher clipPercent of values will be clipped to the min and max of the image).
gVol{sysNum}.clipPercent = 0.2;

% update display
drawnow


%%%%%%%%%%%%%%%%%%%%
%    loadVolume    %
%%%%%%%%%%%%%%%%%%%%
function tf = loadVolume(filename,sysNum)

tf = false;
global gVol;

% display header
if gVol{sysNum}.verbose
  tic
  dispHeader(sprintf('Loading image: %s',mlrImageArgFilename(filename)));
end

% load image
[d h] = mlrImageLoad(filename,'verbose',gVol{sysNum}.verbose);
if isempty(d) || ~mlrImageIsHeader(h),return,end

% make 2D images into nominal 3D
if h.nDim==2
  % but we can't align 2D volumes (because interp3 will fail), so bail out if this is
  % an alignment volume
  if gVol{sysNum}.n >= 1
    disp(sprintf('(mlrVol:loadVolume) !!! Can not align 2D image: %s !!!',mlrImageArgFilename(filename)));
    return
  end
  h.nDim = 3;
  h.dim(3) = 1;
  h.pixdim(3)  = 1;
end

% updated number of volumes
gVol{sysNum}.n = gVol{sysNum}.n+1;
n = gVol{sysNum}.n;

% set volume number
vol.volnum = n;

% set the fields of the volume, if this is compex then split into abs and angle
if isreal(d)
  vol.data = d;
else
  gVol{sysNum}.dispComplex = 'magnitude';
  vol.complexData = d;
  vol.data = abs(d);
end
vol.h = h;

% set which figure numbers this volume will display into
vol.fig(1:3) = gVol{sysNum}.fig(1:3);

% set which subplot
vol.subplotNum(1:3) = (1:3)+(n-1)*3;

% update the axis information for this vol
% this sets how the image will be displayed
vol = updateVolAxisInfo(sysNum,vol,h);

% set the coordinate (start displaying in middle of volume)
coord = round(h.dim/2);
% nDims hard coded to 5 here
coord(end+1:5) = 1;

% set the current coordinates for the first time
vol.curCoord = [nan nan nan];

% print out the header of the image
dispHeaderInfo(sysNum,vol);

% see what other transforms we have
vol.altXforms.shortNames = {};
vol.altXforms.names = {};
vol.altXforms.xforms = {};
vol.altXforms.n = 0;
vol.altXforms.currentXform = [];
if ~isempty(h.vol2tal) && ~isempty(h.vol2mag) && ~isempty(h.sform)
  vol.altXforms.names{end+1} = 'Talairach';
  vol.altXforms.shortNames{end+1} = 'Tal';
  vol.altXforms.xforms{end+1} = h.vol2tal * inv(h.vol2mag) * h.sform * shiftOriginXform;
  vol.altXforms.n = vol.altXforms.n+1;
end
if ~isempty(h.vol2mag)
  vol.altXforms.names{end+1} = 'Canonical magnet';
  vol.altXforms.shortNames{end+1} = 'Mag';
  vol.altXforms.xforms{end+1} = h.vol2mag  * shiftOriginXform;
  vol.altXforms.n = vol.altXforms.n+1;
end
if ~isempty(h.qform)
  vol.altXforms.names{end+1} = 'Qform';
  vol.altXforms.shortNames{end+1} = 'Mag';
  vol.altXforms.xforms{end+1} = h.qform * shiftOriginXform;
  vol.altXforms.n = vol.altXforms.n+1;
end

% set the text boxes
if n == 1
  names = {'X','Y','Z','Volume','Receiver'};
  for i = 1:h.nDim
    % make the inc/dec textboxes
    gVol{sysNum}.hCoordTextbox(i) = makeTextboxIncDec(sysNum,coord(i),i,1,i);
    % get name for button
    if i <= length(names)
      name = names{i};
    else 
      name = sprintf('dim %i',i);
    end
    % make the button
    gVol{sysNum}.hButton(i) = makeButton(sysNum,name,i,2,i);
  end
  % make a text box for the value of the voxel
  makeTextbox(sysNum,'Value',2,h.nDim+1);
  gVol{sysNum}.hValTextbox(1) = makeTextbox(sysNum,'',1,h.nDim+1);

  % make the extra coordinates text boxes
  if vol.altXforms.n > 0
    vol.altXforms.currentXform = 1;
    makeExtraCoordControls(sysNum,vol.altXforms.shortNames{vol.altXforms.currentXform},h.nDim+2);
  end
  drawnow
end

% add another row for displaying the image
if n > 1
  % mark that the volume display is "tethered" to the first volume
  vol.tethered = 1;
  % make a cache for storing images
  vol.c = mrCache('init',2*max(vol.h.dim(1:3)));
  % set the initial transform
  vol.xform = getVol2vol(sysNum,vol,gVol{sysNum}.vols(1));
  % set up some info for manual alignment, like what all the alignment steps have been
  gVol{sysNum}.alignmentSteps = {};
  gVol{sysNum}.originalAlignment = vol.xform;
  % add this to the altXforms
  gVol{sysNum}.vols(1).altXforms.names{end+1} = 'Aligned volume';
  gVol{sysNum}.vols(1).altXforms.shortNames{end+1} = 'Vol';
  gVol{sysNum}.vols(1).altXforms.xforms{end+1} = applyOriginXform(inv(vol.xform));
  gVol{sysNum}.vols(1).altXforms.n = vol.altXforms.n+1;
  % set alt coord to this one
  params.altCoord = 'Aligned volume';
  % this will make the extra coord controls only if they haven't already been made
  makeExtraCoordControls(sysNum,'',gVol{sysNum}.vols(1).h.nDim+2);
  changeAltCoord(sysNum,params);
  
  % setup subplotRows and subplotCols
  gVol{sysNum}.subplotRows = [n n n];
  gVol{sysNum}.subplotCols = [3 3 3];
  % redo the subplots
  for i = 1:n
    for j = 1:3
      gVol{sysNum}.a(i,j) = subplot(n,3,j+(i-1)*3);
      cla;
      axis off;
    end
  end
  % set to display controls
%  gVol{sysNum}.displayControls = true;
  drawnow
else
  % first volume is displayed independently
  vol.tethered = 0;
  % make close button
  makeButton(sysNum,'Close',-1,4,1);
  makeButton(sysNum,'Controls',-2,3,1);
  % set some fields to empty
  vol.c = [];
  vol.xform = [];
  drawnow
end

% place some empty fields that will get filled by setVolCoord
vol.coord = [];
vol.viewIndexes = {};

% short filename for displaying
vol.name = getLastDir(vol.h.filename);

% set the vol
gVol{sysNum}.vols(n) = vol;

% now set the coordinate in this created volume
setVolCoord(sysNum,n,coord);

% display header
if gVol{sysNum}.verbose
  dispHeader(sprintf('%s loaded (%s)',mlrImageArgFilename(filename),mlrDispElapsedTime(toc)));
end

tf = true;

%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    updateVolAxisInfo    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%
function vol = updateVolAxisInfo(sysNum,vol,h)

global gVol;

% compute magnet directions of each axis based on qform and then
% choose which axis will be displayed in what figure based on this
% information
if ~isempty(h.qform) && ~gVol{sysNum}.imageOrientation
%  [axisLabels vol.axisDirLabels vol.axisMapping axisReverseMapping vol.axisDir] = mlrImageGetAxisLabels(h.qform);
  axisLabels = mlrImageGetAxisLabels(h.qform);
  vol.axisDirLabels = axisLabels.dirLabels;
  vol.axisMapping = axisLabels.mapping;
  vol.axisDir = axisLabels.dir;
  vol.viewDim(1:3) = axisLabels.reverseMapping;
else
  vol.axisDirLabels = [];
  % default to assuming LPI orientation
  vol.axisMapping = [1 2 3];
  vol.axisDir = [1 1 1];
  % no information about what axis is what, so just show each axis in order
  vol.viewDim(1:3) = 1:3;
end

% for convenience set which dimension is x and y for each of the views
% given the viewDim info set above and also info about transposing and flipping
desiredAxis = {[2 3],[1 3],[1 2]};
for iView = 1:3
  % get what the other axis are
  otherDims = setdiff(1:3,vol.viewDim(iView));
  vol.xDim(iView) = otherDims(1);
  vol.yDim(iView) = otherDims(2);
  % next figure out the apporpriate transpose and flips needed to
  % show the images in standard LPI (i.e. the first view will
  % be sagittal with nose to right, second view will be coronal and
  % third view will be axial) all with left is left, right is right
  if vol.axisMapping(otherDims(1)) == desiredAxis{iView}(1)
    % transpose when the desired axis is the same (since
    % images are displayed as y/x by matlab)
    vol.transpose(iView) = 1;
  else
    vol.transpose(iView) = 0;
  end
end

% now make axis labels that can be used for displaying. Note that
% if the axis are flipped, dispSlice will unflip them so we
% have to reverse the order of the labels provided by mlrImageGetAxisLabels
for axisNum = 1:3
  axisLabel = {'X','Y','Z'};
  if isempty(vol.axisDirLabels)
    % no transform, so just use simple X,Y,Z labels
    vol.dispAxisLabels{axisNum} = axisLabel{axisNum};
  else
    % check axis direction
    if vol.axisDir(axisNum) == -1
      % and make reversed labels
      vol.dispAxisLabels{axisNum} = sprintf('%s <- %s -> %s',vol.axisDirLabels{axisNum}{2},axisLabel{axisNum},vol.axisDirLabels{axisNum}{1});
    else
      % and make normal labels
      vol.dispAxisLabels{axisNum} = sprintf('%s <- %s -> %s',vol.axisDirLabels{axisNum}{1},axisLabel{axisNum},vol.axisDirLabels{axisNum}{2});
    end
  end
end

% mynum2str.m
%
%        $Id:$ 
%      usage: mynum2str(num,<sigfigs=2>,<doFixBadChars=false>,<tabs=false>,'compact=true')
%         by: justin gardner
%       date: 09/07/09
%    purpose: num2str that allows setting # of significant figures and also doesn't make so many spaces
%             but still will align numbers from line to line.
%
%             For example, if you set sigfigs=-1 then the program will figure out how many sigfigs are needed
%             to display all numbers and make them align across lines. For example, the following
%             line will produce:
%       e.g.: mynum2str([12.1 -0.001 10.1;-1.3 -12.4 30.01],'sigfigs=-1','compact',false)
%              12.100  -0.001  10.100
%              -1.300 -12.400  30.010
%
%             set sigfigs to the number of significant digits you want to show (numbers are rounded to
%               show the appropriate number of sigfigs).
%             set tabs to true if you want to have each number followed by a tab
%             set compact to false if you want numbers to align from row to row (like in the above example)
%                 the default gives the most compact string possible
%
function s = mynum2str(num,varargin)

% check arguments
if nargin == 0
  help mynum2str
  return
end

% check for empty num, in which case return empty
s = '';
if isempty(num),return,end

% evaluate arguments
sigfigs = [];
doFixBadChars = [];
tabs = [];
compact = [];
getArgs(varargin,{'sigfigs=2','doFixBadChars',false,'tabs',false,'compact',true});

% automatic sigfig
sigFigsEachNum = [];

if sigfigs == -1
  % get how many sigfigs each number needs
  sigFigsEachNum = getSigFigs(num);
  % and get the maximum needed sigfigs
  sigfigs = max(sigFigsEachNum(:));
end

% need sigFigsEachNum if we are doing a compact display
if compact && isempty(sigFigsEachNum)
  sigFigsEachNum = getSigFigs(num,sigfigs);
end

% intialize return
s = '';

% check for non 1d or 2d array
if length(size(num))>2
  disp(sprintf('(mynum2str) Can not display %i dimensional matrix',length(size(s))));
  return
elseif length(size(num)) == 2
  num = num';
  % compute maxnumdigits on the left side of decimal excluding inf and nan
  maxnumdigits = length(sprintf('%i',floor(nanmax(abs(num(~isinf(num(:))))))));
  % if there is an inf or nan, account for that
  if any(isnan(num(:))) | any(isinf(num(:)))
    % if sigfigs is zero then Inf and Nan cannot line up with decimal, so shift over by a space
    if sigfigs == 0
      maxnumdigits = max(maxnumdigits,3);
      if any(num(isinf(num(:)))<0)
	maxnumdigits = max(maxnumdigits,4);
      end
    else
      maxnumdigits = max(maxnumdigits,2);
      if any(num(isinf(num(:)))<0)
	maxnumdigits = max(maxnumdigits,4);
      end
    end
  end
end

% make the string
for j = 1:size(num,2)
  for i = 1:size(num,1)
    % create the formatting string
    if compact
      % create string
      formatString = sprintf('%%s%%0.0%if ',sigFigsEachNum(j,i));
    else
      % figure out how many spaces to add
      if num(i,j) < 0,addspace = '';else addspace = ' ';end
      % get the number of digits to the left of decimal point
      if isnan(num(i,j)) | isinf(num(i,j))
	% for nan or inf, then set spaces so that the Inf or NaN string lines up with decimal
	if sigfigs > 0
	  numDigitsToLeftOfDecimal = 2;
	else
	  numDigitsToLeftOfDecimal = 3;
	end
      else
	% for all other numbers count how many places it takes to represent 
	numDigitsToLeftOfDecimal = length(sprintf('%i',floor(abs(num(i,j)))));
      end
      addspace = [addspace repmat(' ',1,maxnumdigits-numDigitsToLeftOfDecimal)];
      % create string
      formatString = sprintf('%%s%s%%0.0%if ',addspace,sigfigs);
      % add spaces after a nan or inf
      if isnan(num(i,j)) | isinf(num(i,j))
	formatString = sprintf('%s%s',formatString,repmat(' ',1,sigfigs));
      end
    end
    % add tabs if called for
    if tabs
      formatString = sprintf('%s\t',formatString(1:end-1));
    end
    % and update the full string
     s = sprintf(formatString,s,round(num(i,j)*(10^sigfigs))/(10^sigfigs));
  end
  % strip off last space
  s = s(1:end-1);
  % add new line character
  if j ~= size(num,2),s = sprintf('%s\n',s);end
end

% fix bad chars
if doFixBadChars
  s = fixBadChars(s,[],{'.','p'});
  s = s(2:end);
end

%%%%%%%%%%%%%%%%%%%%
%    getSigFigs    %
%%%%%%%%%%%%%%%%%%%%
function retval = getSigFigs(num,maxSigFigs)

% if we want at most 0 sigfigs then just return zero for all elements
if (nargin>=2) && (maxSigFigs == 0)
  retval = zeros(size(num));
  return
end

if nargin == 1
  % maximum number of sigfigs
  maxSigFigs = 6;
  minDiff = 1e-10;
else
  % get the minimum difference that is still considered the same number
  % this is a bit of a hack since at some point due to numerical round
  % off you might be smaller than this limit, but still be different numbers
  % but, this should only mean that you will get less digits than asked
  % for only in the compact case
  minDiff = 10^(-2*maxSigFigs);
end

for i = 1:size(num,1)
  for j = 1:size(num,2)
    % for nan and inf the sigfigs needed are 0
    if isnan(num(i,j)) | isinf(num(i,j))
      retval(i,j) = 0;
    else
      % otherwise find out how many sigfigs are needed
      for iSigfig =  1:maxSigFigs
	% check to see if this number is evenly roundable by this
	% many sig digits
	if (abs(round(num(i,j)*(10^iSigfig))/(10^iSigfig) - num(i,j))) < minDiff
	  break
	end
      end
      retval(i,j) = iSigfig;
    end
  end
end

